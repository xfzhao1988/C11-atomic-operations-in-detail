<!DOCTYPE html>
<!-- saved from url=(0051)https://cloud.tencent.com/developer/article/1638672 -->
<html lang="zh" munual-autotracker-init="" qct-uid="" qct-pv-id="7YMh8smKDCRebd_SZq1Dd" qct-ip="218.23.120.144"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="vjs-styles-defaults">
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid {
        padding-top: 56.25%
      }
    </style><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="format-detection" content="telephone=no"><title>深入理解C11/C++11内存模型-腾讯云开发者社区-腾讯云</title><meta name="subject" content="其他-空类-编程算法,通用技术-编程语言-c++"><meta name="subjectTime" content="2020-06-04 15:19:39"><meta name="articleSource" content="W"><meta name="magicSource" content="N"><meta name="authorType" content="Z"><meta name="productSlug" content="tdsql"><meta name="keywords" content="编程算法,c++"><meta name="description" content="现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这..."><meta property="og:title" content="深入理解C11/C++11内存模型-腾讯云开发者社区-腾讯云"><meta property="og:description" content="现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这..."><meta property="og:image" content="https://cloudcache.tencentcs.com/open_proj/proj_qcloud_v2/gateway/shareicons/cloud.png"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover"><link rel="dns-prefetch" href="https://qccommunity.qcloudimg.com/"><link rel="dns-prefetch" href="https://ask.qcloudimg.com/"><link rel="dns-prefetch" href="https://cloudcache.tencentcs.com/"><link rel="canonical" href="https://cloud.tencent.com/developer/article/1638672"><meta name="next-head-count" content="20"><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/base.css"><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/base-202407101526.css"><style type="text/css">
        .rno-markdown p * {
          white-space: pre-wrap;
          word-break: break-all;
        }
      </style><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/Article-202407041513.css"><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/draft-master-v2.0.111.d4s2ddo9sb.css"><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/tcplayer.min.css"><script type="text/javascript" async="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/destination"></script><script async="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/analytics.js.下载"></script><script async="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/gtm.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/aegis.min.js.下载"></script><script>
              if (Aegis) {
                new Aegis({
                  id: 'dWlmyFvjDnalkbZO8q',
                  env: 'production',
                  onError: true,
                  pagePerformance: true,
                  reportAssetSpeed: true,
                  api: {
                    reportRequest: true,
                    resHeaders: ['x-req-id'],
                  },
                  reportApiSpeed: true,
                  beforeRequest: function (data) {
                    // load js failed
                    if (data.logType === 'log') {
                      if (data.logs.level === '32' && data.logs.msg.indexOf('google') > -1) return false;
                    }
                    var ignoreKeys = [
                      'Script error',
                      'chrome-extension',
                      'qq.com',
                      'queryWeappQrcodeStatus',
                      'login/ajax/info',
                      'woa.com',
                      'trafficCollect.php',
                      'google',
                      'dscache',
                      'act-api',
                      'set_qc_cookie',
                      'opc.cloud.tencent.com',
                      'uc_gre_ad_buss',
                      'eb.xcj.pub',
                      'UCShellJava',
                      '/developer/labs/quick/loader',
                      'edgeImmersiveReaderDOM',
                      'sendBeacon',
                      'error-decoder.html'
                    ];
                    var alarmMsg = [data.logs.url, data.logs.msg].join('|');
                    for (var i = 0; i < ignoreKeys.length; i++) {
                      if (alarmMsg.indexOf(ignoreKeys[i]) != -1) return false;
                    }
                    if (/bot|wechatdevtools|spider/i.test(navigator.userAgent)) {
                      return false;
                    }
                    if (location.hostname.indexOf('cloud.tencent.') === -1) {
                      return false;
                    }
                  },
                });
              }
    </script><link rel="preload" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/39f449b3fd0e7d7d.css" as="style"><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/39f449b3fd0e7d7d.css" data-n-g=""><link rel="preload" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/53e572c46176f71a.css" as="style"><link rel="stylesheet" href="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/53e572c46176f71a.css" data-n-p=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/polyfills-c67a75d1b6f99dc8.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/webpack-af9c9018b569e653.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/framework-bae252e255276064.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/main-7da41932fd580784.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/_app-90c80028d7feccdf.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/7247-b29db76fc7394892.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/9516-ed06f8b5b6d7461c.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/3560-1b350c07259e815f.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/3127-2d265d7011e04a8f.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/6249-8c67f10599327a0e.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/9835-7f3adb837c602e11.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/503-62afac4ccb82a529.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/1925-36f73c55c4d2f952.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/3887-0dcd5d3152f3302c.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/2418-1e98ff5353c4371a.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/6415-784cef7adb6b1a60.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/404-c2b9b4dabf86f7f8.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/1870-ec71c5134fdbdc19.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/6517-328a4a00de77be8b.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/5668-e4f387c51ee6fe82.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/1323-5a3b99daaaac578e.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/6387-05874ad0d8879f81.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/6315-a18fbcf2effa9c20.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/4525-d56aaefefd3ad282.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/[articleId]-8b63caba5f4101ec.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/_buildManifest.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/_ssgManifest.js.下载" defer=""></script><script type="text/javascript" async="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/MathJax.js.下载"></script><script type="text/javascript" async="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/f.txt"></script><style id="dynamic-inserted-css-tea-transition-scale-738412514">
.tea-transition-scale-738412514-enter {
    opacity: 0 !important;
    transform: scale3d(0.94, 0.94, 0.94);
    transform-origin: bottom;
}
.tea-transition-scale-738412514-enter-active {
    opacity: 1 !important;
    transform: scale3d(1, 1, 1);
    transition: opacity 50ms ease,
                transform 50ms ease;
    transform-origin: bottom;
}
.tea-transition-scale-738412514-exit {
    opacity: 1 !important;
    transform: scale3d(1, 1, 1);
    transform-origin: bottom;
}
.tea-transition-scale-738412514-exit-active {
    opacity: 0 !important;
    transform: scale3d(0.94, 0.94, 0.94);
    transition: opacity 300ms ease,
                transform 300ms ease;
    transform-origin: bottom;
}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><script type="text/javascript" async="" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/f(1).txt"></script><style id="dynamic-inserted-css-tea-transition-scale-736984168">
.tea-transition-scale-736984168-enter {
    opacity: 0 !important;
    transform: scale3d(0.94, 0.94, 0.94);
    transform-origin: top;
}
.tea-transition-scale-736984168-enter-active {
    opacity: 1 !important;
    transform: scale3d(1, 1, 1);
    transition: opacity 50ms ease,
                transform 50ms ease;
    transform-origin: top;
}
.tea-transition-scale-736984168-exit {
    opacity: 1 !important;
    transform: scale3d(1, 1, 1);
    transform-origin: top;
}
.tea-transition-scale-736984168-exit-active {
    opacity: 0 !important;
    transform: scale3d(0.94, 0.94, 0.94);
    transition: opacity 300ms ease,
                transform 300ms ease;
    transform-origin: top;
}
</style><style id="dynamic-inserted-css-tea-transition-scale-1610162950">
.tea-transition-scale-1610162950-enter {
    opacity: 0 !important;
    transform: scale3d(0.94, 0.94, 0.94);
    transform-origin: left;
}
.tea-transition-scale-1610162950-enter-active {
    opacity: 1 !important;
    transform: scale3d(1, 1, 1);
    transition: opacity 50ms ease,
                transform 50ms ease;
    transform-origin: left;
}
.tea-transition-scale-1610162950-exit {
    opacity: 1 !important;
    transform: scale3d(1, 1, 1);
    transform-origin: left;
}
.tea-transition-scale-1610162950-exit-active {
    opacity: 0 !important;
    transform: scale3d(0.94, 0.94, 0.94);
    transition: opacity 300ms ease,
                transform 300ms ease;
    transform-origin: left;
}
</style></head><body class=""><div id="MathJax_Message" style="display: none;"></div><div id="__next"><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/qcloudStatApi.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/exposure-plugin-4.1.15.min.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/qcloud-community-track.min.js.下载"></script><div class="cdc-responsive-layout" aegis-first-screen-timing="true" qct-area="文章详情页"><div class="cdc-article-page cdc-global is-bannerFocus"><div class="cdc-sticky-header mod-sticky-header is-hidden" style="left: 0px;"><a class="cdc-top-ad" href="https://cloud.tencent.com/act/pro/Featured?from=22374&amp;from_column=22374#newuser" target="_blank" qct-area="吸顶广告条" qct-exposure="" qct-click="" style="background-image: url(&quot;https://cloudcache.tencent-cloud.com/qcloud/ui/static/static_source_business/ffda301e-6166-4081-809b-bec53e99ab66.png&quot;);"><i class="icon-close TopAdCloseBtn"></i></a><div class="cdc-sticky-header__inner"><div class="cdc-sticky-header__main"><div class="mod-sticky-header__main"><div class="mod-sticky-header__author"><span class="cdc-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/5465588" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/random-avatar/5465588/kn484luc7w.png&quot;);"></a></span><div class="author-info"><a class="author-info__name" href="https://cloud.tencent.com/developer/user/5465588" target="_blank"><span class="name-text">Linux阅码场</span></a><div class="author-info__article"><i class="icon-recommend"></i>作者相关精选</div></div></div><div class="mod-sticky-header__split"></div><div class="mod-sticky-header__title"><h2 class="title-text">深入理解C11/C++11内存模型</h2></div></div></div><div class="cdc-sticky-header__extra"><div class="mod-sticky-header__operates"><button class="cdc-btn mod-sticky-header__operate btn-focus cdc-btn--primary"><i class="add-icon"></i><span>关注作者</span></button></div></div></div></div><div class="cdc-m-guider-banner"><div class="cdc-m-guider-banner__guide-mvp is-detail-page"><div class="cdc-m-guider-banner__guide-mvp-text">前往小程序，Get<em>更优</em>阅读体验！</div><div class="cdc-m-guider-banner__guide-mvp-btn">立即前往</div></div></div><div class="cdc-header cdc-header--block show-ad" track="导航"><div class="cdc-header__placeholder"></div><div class="cdc-header__inner"><a class="cdc-top-ad" href="https://cloud.tencent.com/act/pro/Featured?from=22374&amp;from_column=22374#newuser" target="_blank" qct-area="吸顶广告条" qct-exposure="" qct-click="" style="background-image: url(&quot;https://cloudcache.tencent-cloud.com/qcloud/ui/static/static_source_business/ffda301e-6166-4081-809b-bec53e99ab66.png&quot;);"><i class="icon-close TopAdCloseBtn"></i></a><div class="cdc-header__top"><div class="cdc-header__top-left"><a href="https://cloud.tencent.com/?from=20060&amp;from_column=20060" target="_blank" class="cdc-header__top-logo" hotrep="" track="腾讯云官网入口"><i>腾讯云</i></a><div class="cdc-header__top-line"></div><a href="https://cloud.tencent.com/developer" class="cdc-header__top-logo community"><i>开发者社区</i></a><div class="cdc-header__activity"></div></div><div class="cdc-header__top-operates"><a href="https://cloud.tencent.com/document/product?from=20702&amp;from_column=20702" target="_blank" class="cdc-header__link">文档</a><a href="https://cloud.tencent.com/voc/?from=20703&amp;from_column=20703" target="_blank" class="cdc-header__link">建议反馈</a><a href="https://console.cloud.tencent.com/?from=20063&amp;from_column=20063" target="_blank" class="cdc-header__link" track-click="{&quot;areaId&quot;:102001,&quot;subAreaId&quot;:1}">控制台</a></div></div><div class="cdc-header__bottom"><div class="cdc-header__bottom-nav"><a href="https://cloud.tencent.com/developer" class="cdc-header__bottom-home">首页</a><div class="cdc-header__nav-list"><div class="cdc-header__nav-item">学习</div><div class="cdc-header__nav-item">活动</div><div class="cdc-header__nav-item">专区</div><div class="cdc-header__nav-item">工具</div></div><a href="https://cloud.tencent.com/tvp?from=20154&amp;from_column=20154" class="cdc-header__tvp" target="_blank">TVP</a><div class="cdc-header__activity"><a class="cdc-header__activity-tit" href="https://cloud.tencent.com/act?from=20061&amp;from_column=20061" target="_blank">最新优惠活动<div class="cdc-badge"><div class="cdc-badge-inner"><div class="cdc-badge-text"></div></div></div></a></div><a track-click="{&quot;areaId&quot;:1000,&quot;objectType&quot;:&quot;ad&quot;,&quot;objectId&quot;:1531}" track-exposure="{&quot;areaId&quot;:1000,&quot;objectType&quot;:&quot;ad&quot;,&quot;objectId&quot;:1531}" href="https://chatbi.cloud.tencent.com/?from=22356" target="_blank" class="cdc-header__capsule"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/20240702-83be1e42.png" alt="广告"></a></div><div class="cdc-header__bottom-operates"><div class="cdc-header__search"><div class="cdc-search__wrap"><div class="cdc-search"><span class="cdc-search__text">文章/答案/技术大牛</span><button class="cdc-search__btn">搜索<i class="cdc-search__i search"></i></button></div><div class="cdc-search__dropdown"><div class="cdc-search__bar"><input type="text" class="cdc-search__bar-input" placeholder="文章/答案/技术大牛" value=""><div class="cdc-search__bar-btns"><button class="cdc-search__btn">搜索<i class="cdc-search__i search"></i></button><button class="cdc-search__btn">关闭<i class="cdc-search__i clear"></i></button></div></div></div></div></div><div class="cdc-header__create"><span class="cdc-header__create-btn"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 16px; height: 16px;"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M14.2466 12.0145C14.1698 13.6258 12.8381 14.9131 11.2129 14.9131H11.1579H4.0927H4.03772C2.4125 14.9131 1.08014 13.6258 1.00334 12.0145H1V11.8668V4.07213V4.04627V3.89922H1.00334C1.08014 2.28732 2.4125 1 4.03772 1H9.6473V1.00069H10.0786L8.7688 2.10773H8.43888H7.7916H6.37904H4.03772C2.97234 2.10773 2.10445 2.9777 2.10445 4.04629V4.41869V4.4472V6.39498V11.4269V11.4309V11.8668C2.10445 12.9354 2.97234 13.8053 4.03772 13.8053H6.37904H8.87153H11.2129C12.2782 13.8053 13.1461 12.9355 13.1461 11.8668V11.466V11.454V9.5181V6.39364L14.2506 5.3051V11.8668V12.0145H14.2466ZM10.4324 7.15226L9.63146 7.99761C9.36577 8.2693 8.69326 8.95104 8.48066 9.17631C8.26726 9.40288 8.09039 9.58901 7.95061 9.73544C7.81079 9.88188 7.72667 9.96597 7.70083 9.98656C7.63321 10.0488 7.55703 10.1144 7.47022 10.1846C7.38412 10.2542 7.29404 10.3099 7.20063 10.3516C7.10722 10.4007 6.97072 10.459 6.79049 10.5305C6.61028 10.6001 6.42213 10.6676 6.22468 10.7339C6.02792 10.8002 5.84109 10.8571 5.66484 10.9061C5.48795 10.9538 5.3561 10.9863 5.2693 11.0009C5.08977 11.0214 4.96988 10.993 4.90956 10.9168C4.84931 10.8405 4.83276 10.7107 4.85924 10.5312C4.87315 10.4331 4.9043 10.292 4.95468 10.1078C5.00431 9.92297 5.05802 9.7315 5.11431 9.53341C5.1713 9.33526 5.22629 9.15179 5.27926 8.98484C5.33297 8.8179 5.37599 8.7026 5.40978 8.64032C5.44953 8.54357 5.49463 8.45413 5.54495 8.37399C5.59465 8.29379 5.66616 8.20503 5.75965 8.10766C5.79934 8.06588 5.89281 7.96649 6.03988 7.81018C6.18624 7.65311 6.80114 7.02774 7.02104 6.79783L7.75117 6.03524L8.56212 5.1899L10.6345 3.02466L12.5214 4.93874L10.4324 7.15226ZM13.816 3.58581C13.7166 3.68987 13.6272 3.78064 13.5483 3.85883C13.4694 3.93703 13.4006 4.0066 13.3423 4.06686C13.276 4.13643 13.2144 4.19738 13.1561 4.24903L11.2785 2.33569C11.3785 2.24025 11.4965 2.12565 11.6336 1.99115C11.7707 1.85668 11.8854 1.75061 11.9761 1.67242C12.0934 1.57708 12.2133 1.51013 12.3385 1.47109C12.4525 1.43529 12.5644 1.41805 12.6751 1.41876H12.7056C12.7665 1.42139 12.8268 1.42729 12.8851 1.43724C12.8838 1.4366 12.8811 1.43724 12.8798 1.4366C12.8811 1.4366 12.8838 1.4366 12.8851 1.43724C13.1376 1.48428 13.4019 1.62009 13.6265 1.83743C13.7511 1.95871 13.8524 2.09382 13.9259 2.23296C14.0346 2.43834 14.0863 2.65304 14.0763 2.8491C14.0763 2.87294 14.0783 2.89748 14.0783 2.92201C14.0783 3.03529 14.0571 3.14789 14.0154 3.26055C13.9737 3.37314 13.9067 3.48185 13.816 3.58581Z" fill="white"></path></svg></span></span>发布<span class="cdc-svg-icon-con cdc-header__create-btn-arrow"><span class="cdc-svg-icon" style="width: 16px; height: 16px;"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M8.16377 4L9.57798 5.41421L14.5277 10.364L13.1135 11.7782L8.1638 6.829L3.21402 11.7782L1.7998 10.364L8.16377 4Z"></path></svg></span></span></span></div><div class="cdc-header__account"><div class="cdc-header__account-inner"><button class="cdc-btn cdc-header__account-btn cdc-btn--primary">登录/注册</button></div></div></div></div></div></div><div class="cdc-m-sticky-header is-hidden is-sticky"><div class="cdc-m-sticky-header__placeholder"></div><div class="cdc-m-sticky-header__main"><div class="cdc-m-sticky-header__con"><div class="cdc-m-sticky-header__trigger"></div><div class="cdc-m-header-article__menu"><div class="cdc-m-header-article__menu-mask"></div><div class="cdc-m-header-article__menu-side"><div class="cdc-m-header__sidebar"><div class="cdc-m-header__sidebar-top"><i class="cdc-m-header__sidebar-top__logo"></i><span class="cdc-m-header__sidebar-top__back"></span></div><div class="cdc-m-header__sidebar-menus"><div class="cdc-m-header__sidebar-capsule"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/20240702-1ec1af69.png" alt="广告"></div><a href="https://cloud.tencent.com/developer" class="cdc-m-header__sidebar-menu link">首页</a><div class="tpm1-collapse"><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">学习</div></header></div><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">活动</div></header></div><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">专区</div></header></div><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">工具</div></header></div></div><a href="https://cloud.tencent.com/tvp?from=20154&amp;from_column=20154" class="cdc-m-header__sidebar-menu link">TVP</a><a class="cdc-m-header__sidebar-activity" href="https://cloud.tencent.com/act?from=20061&amp;from_column=20061" target="_blank">最新优惠活动<div class="cdc-badge"><div class="cdc-badge-inner"><div class="cdc-badge-text"></div></div></div></a></div><div class="cdc-m-header__sidebar-back"><a href="https://cloud.tencent.com/?from=20060&amp;from_column=20060" class="cdc-m-header__sidebar-back__link"><i></i><span>返回腾讯云官网</span></a></div></div></div></div><div class="cdc-m-sticky-header__author"><span class="cdc-avatar large circle" style="cursor: unset;"><span class="cdc-avatar__inner" style="background-image: url(&quot;https://ask.qcloudimg.com/random-avatar/5465588/kn484luc7w.png&quot;);"></span></span><div class="cdc-m-sticky-header__author-name">Linux阅码场</div></div></div><div class="cdc-m-sticky-header__extra"><div class="cdc-m-sticky-header__extra-icon"><i class="extra-search"></i></div><div class="cdc-m-sticky-header__extra-icon"><i class="extra-share"></i></div><div class="cdc-m-sticky-header__extra-operate"><div class="cdc-m-sticky-header__extra-icon"><i class="extra-man"></i></div></div></div></div></div><div class="cdc-m-header-article"><div class="cdc-m-header-article__placeholder"></div><div class="cdc-m-header-article__content"><div class="cdc-m-header-article__main"><div class="cdc-m-header-article__con"><div class="cdc-m-header-article__trigger"></div><div class="cdc-m-header-article__menu"><div class="cdc-m-header-article__menu-mask"></div><div class="cdc-m-header-article__menu-side"><div class="cdc-m-header__sidebar"><div class="cdc-m-header__sidebar-top"><i class="cdc-m-header__sidebar-top__logo"></i><span class="cdc-m-header__sidebar-top__back"></span></div><div class="cdc-m-header__sidebar-menus"><div class="cdc-m-header__sidebar-capsule"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/20240712-7dd582d0.png" alt="广告"></div><a href="https://cloud.tencent.com/developer" class="cdc-m-header__sidebar-menu link">首页</a><div class="tpm1-collapse"><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">学习</div></header></div><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">活动</div></header></div><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">专区</div></header></div><div class="tpm1-collapse__panel"><header class="tpm1-collapse__panel-hd"><div class="tpm1-collapse__panel-title">工具</div></header></div></div><a href="https://cloud.tencent.com/tvp?from=20154&amp;from_column=20154" class="cdc-m-header__sidebar-menu link">TVP</a><a class="cdc-m-header__sidebar-activity" href="https://cloud.tencent.com/act?from=20061&amp;from_column=20061" target="_blank">最新优惠活动<div class="cdc-badge"><div class="cdc-badge-inner"><div class="cdc-badge-text"></div></div></div></a></div><div class="cdc-m-header__sidebar-back"><a href="https://cloud.tencent.com/?from=20060&amp;from_column=20060" class="cdc-m-header__sidebar-back__link"><i></i><span>返回腾讯云官网</span></a></div></div></div></div></div><div class="cdc-m-header-article__title"><div class="cdc-m-header-article__title-logo"></div></div><div class="cdc-m-header-article__extra"><div class="cdc-m-header-article__extra-icon"><i class="extra-search"></i></div><div class="cdc-m-header-article__extra-operate"><div class="cdc-m-header-article__extra-icon"><i class="extra-man"></i></div></div></div></div></div></div><div class="cdc-global__main"><div class="cdc-article__body"><div class="cdc-layout"><div class="cdc-layout__main"><div class="cdc-crumb mod-crumb"><div class="cdc-crumb__inner"><a class="cdc-crumb__item" href="https://cloud.tencent.com/developer">社区首页</a><span class="cdc-crumb__split"> &gt;</span><a class="cdc-crumb__item" href="https://cloud.tencent.com/developer/column">专栏</a><span class="cdc-crumb__split"> &gt;</span><span class="cdc-crumb__item current">深入理解C11/C++11内存模型</span></div></div><div class="mod-article-content"><div class="mod-header"><div class="mod-header__top"><div class="mod-header__title"><h1 class="title-text">深入理解C11/C++11内存模型</h1></div></div><div class="mod-article-source header"><div class="mod-article-source__main"><div class="mod-article-source__avatar"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/kn484luc7w.png" alt="作者头像"></div><div class="mod-article-source__detail"><div class="mod-article-source__name"><span>Linux阅码场</span></div></div><button class="cdc-btn mod-article-source__operate cdc-btn--primary"><span><i></i>关注</span></button></div></div><div class="mod-header__bottom"><div class="mod-header__detail"><div class="mod-header__date"><span class="date-text">发布于 2020-06-04 15:19:39</span></div><div class="mod-header__infos"><div class="cdc-icon__list"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 16px; height: 16px;"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><g id="icon-view" transform="translate(0.000000, 3.000000)" fill="currentcolor" fill-rule="nonzero"><path d="M15.885,4.68036 C14.9951,3.57569 11.7987,-0.004272 7.99883,-0.004272 C4.19895,-0.004272 1.02302,3.57569 0.112682,4.68036 C0.040058,4.77107 0.000488281,4.88381 0.000488281,5 C0.000488281,5.1162 0.040058,5.22894 0.112682,5.31964 C1.00767,6.42432 4.20407,10.0043 7.99883,10.0043 C11.7936,10.0043 14.9951,6.42432 15.885,5.31964 C15.9576,5.22894 15.9972,5.1162 15.9972,5 C15.9972,4.88381 15.9576,4.77107 15.885,4.68036 Z M7.99883,8.97632 C4.93029,8.97632 2.25555,6.25043 1.17644,4.99745 C2.25555,3.74446 4.95586,1.01857 7.99883,1.01857 C11.0418,1.01857 13.7421,3.74446 14.8314,4.99745 C13.7421,6.25043 11.0418,8.97632 7.99883,8.97632 Z" id="形状"></path><path d="M7.97304,2.55286 C7.49865,2.55286 7.03491,2.69353 6.64046,2.95709 C6.24602,3.22065 5.93859,3.59525 5.75704,4.03354 C5.5755,4.47182 5.528,4.95409 5.62055,5.41937 C5.7131,5.88465 5.94154,6.31203 6.27699,6.64748 C6.61244,6.98293 7.03982,7.21137 7.5051,7.30392 C7.97038,7.39647 8.45265,7.34897 8.89093,7.16743 C9.32922,6.98588 9.70382,6.67845 9.96738,6.28401 C10.2309,5.88956 10.3716,5.42582 10.3716,4.95143 C10.3716,4.31529 10.1189,3.7052 9.66909,3.25538 C9.21927,2.80556 8.60918,2.55286 7.97304,2.55286 Z M7.97304,6.32716 C7.70095,6.32716 7.43496,6.24647 7.20872,6.09531 C6.98249,5.94414 6.80616,5.72928 6.70203,5.4779 C6.59791,5.22652 6.57066,4.94991 6.62374,4.68304 C6.67683,4.41617 6.80785,4.17104 7.00025,3.97864 C7.19265,3.78625 7.43778,3.65522 7.70465,3.60214 C7.97151,3.54905 8.24813,3.5763 8.49951,3.68042 C8.75089,3.78455 8.96575,3.96088 9.11692,4.18712 C9.26808,4.41335 9.34877,4.67934 9.34877,4.95143 C9.35012,5.13295 9.31553,5.31295 9.247,5.48104 C9.17846,5.64913 9.07734,5.802 8.94946,5.93084 C8.82158,6.05967 8.66946,6.16192 8.50188,6.2317 C8.3343,6.30147 8.15457,6.33739 7.97304,6.33739 L7.97304,6.32716 Z" id="形状"></path></g></svg></span><span class="cdc-svg-icon-text">2.4K</span></span><span class="cdc-svg-icon-con is-comment"><span class="cdc-svg-icon" style="width: 16px; height: 16px;"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8 13.414L5.58594 11H2V3H14V11H10.4141L8 13.414ZM5.17175 12L8 14.8282L10.8282 12H15V2H1V12H5.17175ZM4 6C3.44775 6 3 6.44769 3 7C3 7.55231 3.44775 8 4 8C4.55225 8 5 7.55231 5 7C5 6.44769 4.55225 6 4 6ZM7 7C7 6.44769 7.44775 6 8 6C8.55225 6 9 6.44769 9 7C9 7.55231 8.55225 8 8 8C7.44775 8 7 7.55231 7 7ZM12 6C11.4478 6 11 6.44769 11 7C11 7.55231 11.4478 8 12 8C12.5522 8 13 7.55231 13 7C13 6.44769 12.5522 6 12 6Z"></path></svg></span><span class="cdc-svg-icon-text">0</span></span></div></div><div class="mod-header__date is-mobile"><span class="date-text">发布于 2020-06-04 15:19:39</span></div></div><div class="mod-header__operates"><div class="mod-header__operate"><span class="cdc-svg-icon-con is-operate"><span class="cdc-svg-icon" style="width: 16px; height: 16px;"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.21101 2.54545C8.80733 1.81818 7.79814 1.81818 7.39446 2.54545L1.94481 12.3636C1.54113 13.0909 2.04573 14 2.85308 14H13.7524C14.5597 14 15.0643 13.0909 14.6607 12.3636L9.21101 2.54545ZM2.85308 12.9091L8.30273 3.09091L13.7524 12.9091H2.85308ZM8.00037 6H9.00037V10H8.00037V6ZM8.00037 11H9.00037V12H8.00037V11Z" fill="currentcolor"></path></svg></span><span class="cdc-svg-icon-text">举报</span></span></div></div></div><div class="mod-header__column"><span><i class="mod-header__column-icon"></i>文章被收录于专栏：</span><a class="mod-header__column-name" href="https://cloud.tencent.com/developer/column/77185" target="_blank">LINUX阅码场</a><span class="mod-header__column-first"><a class="mod-header__column-first-text" href="https://cloud.tencent.com/developer/column/77185">LINUX阅码场</a></span></div></div><div class="mod-content"><div class="mod-content__markdown"><div><div class="rno-markdown new-version rno-"><p>现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这是多处理器架构下并发编程里必须掌握的一个基础概念。</p><p>1. 什么是内存模型？
</p><p>到底什么是内存模型呢？看到有两种不同的观点：</p><ul class="ul-level-0"><li>A：内存模型是从来描述编程语言在支持多线程编程中对共享内存访问的顺序。</li><li>B：内存模型的本质是指在单线程情况下CPU指令在多大程度上发生指令重排(reorder)[1]。</li></ul><p>实际上A，B两种说法都是正确的，只不过是在尝试从不同的角度去说明memory model的概念。个人认为，内存模型表达为“内存顺序模型”可能更加贴切一点。</p><p>一个良好的memory model定义包含3个方面：</p><ul class="ul-level-0"><li>Atomic Operations</li><li>Partial order of operations</li><li>Visable effects of operations</li></ul><p>这里要强调的是：我们这里所说的内存模型和CPU的体系结构、<span class="mod-overview__keyword">编译器</span>实现和编程语言规范3个层面都有关系。</p><p>首先，不同的CPU体系结构内存顺序模型是不一样的，但大致分为两种：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left;"><div><div class="table-header"><p>Architecture</p></div></div></th><th style="text-align: left;"><div><div class="table-header"><p>Memory Model</p></div></div></th></tr></thead><tbody><tr><td style="text-align: left;"><div><div class="table-cell"><p>x86_64</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>Total Store Order</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>Sparc</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>Total Store Order</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>ARMv8</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>Weakly Ordered</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>PowerPC</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>Weakly Ordered</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>MIPS</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>Weakly Ordered</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p></p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p></p></div></div></td></tr></tbody></table></div><p>x86_64和Sparc是强顺序模型（Total Store Order），这是一种接近程序顺序的顺序模型。所谓Total，就是说，内存（在写操作上）是有一个全局的顺序的（所有人看到的一样的顺序）， 就好像在内存上的每个Store动作必须有一个排队，一个弄完才轮到另一个，这个顺序和你的程序顺序直接相关。所有的行为组合只会是所有CPU内存程序顺序的交织，不会发生和程序顺序不一致的地方[4]。TSO模型有利于多线程程序的编写，对程序员更加友好，但对芯片实现者不友好。CPU为了TSO的承诺，会牺牲一些并发上的执行效率。</p><p>弱内存模型（简称WMO，Weak Memory Ordering），是把是否要求强制顺序这个要求直接交给程序员的方法。换句话说，CPU不去保证这个顺序模型（除非他们在一个CPU上就有依赖）， 程序员要主动插入内存屏障指令来强化这个“可见性”[4]。ARMv8，PowerPC和MIPS等体系结构都是弱内存模型。每种弱内存模型的体系架构都有自己的内存屏障指令，语义也不完全相同。弱内存模型下，硬件实现起来相对简单，处理器执行的效率也高， 只要没有遇到显式的屏障指令，CPU可以对局部指令进行reorder以提高执行效率。</p><p>对于多线程程序开发来说，对并发的数据访问我们一般到做同步操作， 可以使用mutex，semaphore，conditional等重量级方案对共享数据进行保护。但为了实现更高的并发，需要使用内存共享变量做通信（Message Passing）， 这就对程序员的要求很高了，程序员必须时时刻刻必须很清楚自己在做什么， 否则写出来的程序的执行行为会让人很是迷惑！值得一提的是，并发虽好，如果能够简单粗暴实现，就不要搞太多投机取巧！要实现lock-free无锁编程真的有点难。</p><p>其次，不同的编程语言对内存模型都有自己的规范，例如：C/C++和<span class="mod-overview__keyword">Java</span>等不同的编程语言都有定义内存模型相关规范。</p><p>2011年发布的C11/C++11 ISO Standard为我们带来了memory order的支持， 引用C++11里的一段描述：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">The memory model means that <span class="token constant">C</span><span class="token operator">++</span> code now has a standardized
library to call regardless <span class="token keyword">of</span> who made the compiler and on
what platform it<span class="token string">'s running. There'</span>s a standard way to control
how different threads talk to the processor's memory<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></div><p>memory order的问题就是因为指令重排引起的, 指令重排导致 原来的内存可见顺序发生了变化, 在单线程执行起来的时候是没有问题的, 但是放到 多核/多线程执行的时候就出现问题了, 为了效率引入的额外复杂逻辑的的弊端就出现了[8]。</p><p>C++11引入memory order的意义在于我们现在有了一个与运行平台无关和编译器无关的标准库， 让我们可以在high level languange层面实现对多处理器对共享内存的交互式控制。我们的多线程终于可以跨平台啦！我们可以借助内存模型写出更好更安全的并发代码。真棒，简直不要太优秀~</p><figure class=""><div class="rno-markdown-img-url" style="text-align: center;"><div class="rno-markdown-img-url-inner" style="width: 69.9%;"><div style="width: 100%;"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/93t5m0g6j5.png"></div></div></div></figure><p>C11/C++11使用memory order来描述memory model， 而用来联系memory order的是atomic变量， atomic操作可以用load()和release()语义来描述。一个简单的atomic变量赋值可描述为：
</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;"> atomic_var1<span class="token punctuation">.</span><span class="token function">store</span> <span class="token punctuation">(</span>atomic_var2<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// atomic variables</span>
     vs
 var1 <span class="token operator">=</span> var2<span class="token punctuation">;</span>                            <span class="token comment">// regular variables</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></div><p>为了更好地描述内存模型，有4种关系术语需要了解一下。</p><p>sequenced-before</p><p>同一个线程之内，语句A的执行顺序在语句B前面，那么就成为A sequenced-before B。它不仅仅表示两个操作之间的先后顺序，还表示了操作结果之间的可见性关系。两个操作A和操作B，如果有A sequenced-before B，除了表示操作A的顺序在B之前，还表示了操作A的结果操作B可见。例如：语句A是sequenced-before语句B的。</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">r2 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// B</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></div><h4 id="76k1h" name="happens-before">happens-before</h4><p>happens-before关系表示的不同线程之间的操作先后顺序。如果A happens-before B，则A的内存状态将在B操作执行之前就可见。happends-before关系满足传递性、非自反性和非对称性。happens before包含了inter-thread happens before和synchronizes-with两种关系。</p><p>synchronizes-with</p><p>synchronizes-with关系强调的是变量被修改之后的传播关系（propagate）， 即如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的[9]。另外synchronizes-with可以被认为是跨线程间的happends-before关系。显然，满足synchronizes-with关系的操作一定满足happens-before关系了。</p><p>Carries dependency</p><p>同一个线程内，表达式A sequenced-before 表达式B，并且表达式B的值是受表达式A的影响的一种关系， 称之为"Carries dependency"。这个很好理解，例如：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">int <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">&amp;</span>var1<span class="token punctuation">;</span>
int <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>var2<span class="token punctuation">;</span>
c <span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></div><p>了解了上面一些基本概念，下面我们来一起学习一下内存模型吧。</p><p>2. C11/C++11内存模型</p><p>C/C++11标准中提供了6种memory order，来描述内存模型[6]:</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;"><span class="token keyword">enum</span> memory_order <span class="token punctuation">{</span>
    memory_order_relaxed<span class="token punctuation">,</span>
    memory_order_consume<span class="token punctuation">,</span>
    memory_order_acquire<span class="token punctuation">,</span>
    memory_order_release<span class="token punctuation">,</span>
    memory_order_acq_rel<span class="token punctuation">,</span>
    memory_order_seq_cst
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><p>每种memory order的规则可以简要描述为：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left;"><div><div class="table-header"><p>枚举值</p></div></div></th><th style="text-align: left;"><div><div class="table-header"><p>定义规则</p></div></div></th></tr></thead><tbody><tr><td style="text-align: left;"><div><div class="table-cell"><p>memory_order_relaxed</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>不对执行顺序做任何保证</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>memory_order_consume</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>本线程中，所有后续的有关本原子类型的操作，必须在本条原子操作完成之后执行</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>memory_order_acquire</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>本线程中，所有后续的读操作必须在本条原子操作完成后执行</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>memory_order_release</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>本线程中，所有之前的写操作完成后才能执行本条原子操作</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>memory_order_acq_rel</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>同时包含memory_order_acquire和memory_order_release标记</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p>memory_order_seq_cst</p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p>全部存取都按顺序执行</p></div></div></td></tr><tr><td style="text-align: left;"><div><div class="table-cell"><p></p></div></div></td><td style="text-align: left;"><div><div class="table-cell"><p></p></div></div></td></tr></tbody></table></div><figure class=""><div class="rno-markdown-img-url" style="text-align: center;"><div class="rno-markdown-img-url-inner" style="width: 100%;"><div style="width: 100%;"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/ti94sky0rg.png"></div></div></div></figure><p> 下面我们来举例一一说明，扒开内存模型的神秘面纱。</p><p>2.1 memory order releaxed</p><p><code>relaxed</code>表示一种最为宽松的内存操作约定，Relaxed ordering 仅仅保证load()和store()是原子操作， 除此之外，不提供任何跨线程的同步[5]。</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">                   <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// global variable</span>
                   <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// global variable</span>
		  
Thread<span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>                                  Thread<span class="token operator">-</span><span class="token number">2</span><span class="token operator">:</span>
r1 <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A    r2 = x.load(memory_order_relaxed); // C</span>
x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span> memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// B    y.store(42, memory_order_relaxed); // D</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><p>上面的多线程模型执行的时候，可能出现r2 == r1 == 42。要理解这一点并不难，因为CPU在执行的时候允许局部指令重排reorder，D可能在C前执行。如果程序的执行顺序是 D -&gt; A -&gt; B -&gt; C，那么就会出现r1 == r2 == 42。</p><p>如果某个操作只要求是原子操作，除此之外，不需要其它同步的保障，那么就可以使用 relaxed ordering。程序计数器是一种典型的应用场景：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">#include <span class="token operator">&lt;</span>cassert<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>atomic<span class="token operator">&gt;</span>

<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> cnt <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span>std<span class="token operator">:</span><span class="token operator">:</span>thread<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>auto<span class="token operator">&amp;</span> t <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// never failed</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><p><code>cnt</code>是共享的全局变量，多个线程并发地对<code>cnt</code>执行RMW（Read Modify Write）原子操作。这里只保证<code>cnt</code>的原子性，其他有依赖<code>cnt</code>的地方不保证任何的同步。</p><p>2.2 memory order consume</p><p><code>consume</code>要搭配<code>release</code>一起使用。很多时候，线程间只想针对有依赖关系的操作进行同步， 除此之外线程中其他操作顺序如何不关心，这时候就适合用<code>consume</code>来完成这个操作。例如：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">b <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
c <span class="token operator">=</span> <span class="token operator">*</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></div><p>第二行的变量c依赖于第一行的执行结果，因此这两行代码是"Carries dependency"关系。显然，由于<code>consume</code>是针对有明确依赖关系的语句来限定其执行顺序的一种内存顺序， 而<code>releaxed</code>不提供任何顺序保证， 所以consume order要比releaxed order要更加地Strong。</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">#include <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>atomic<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>cassert<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>

<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>std<span class="token operator">:</span><span class="token operator">:</span>string<span class="token operator">*</span><span class="token operator">&gt;</span> ptr<span class="token punctuation">;</span>
int data<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>string<span class="token operator">*</span> p  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">std</span><span class="token operator">:</span><span class="token operator">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    ptr<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>string<span class="token operator">*</span> p2<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p2 <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_consume<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>p2 <span class="token operator">==</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// never fires: *p2 carries dependency from ptr</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// may or may not fire: data does not carry dependency from ptr</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><p>assert(*p2 == "Hello")永远不会失败，但assert(data == 42)可能会。原因是：</p><ul class="ul-level-0"><li>p2和ptr直接有依赖关系，但data和ptr没有直接依赖关系，</li><li>尽管线程1中data赋值在ptr.store()之前，线程2看到的data的值还是不确定的。</li></ul><h4 id="b7jtr" name="2.3-memory-order-acquire">2.3 memory order acquire</h4><p><code>acquire</code>和<code>release</code>也必须放到一起使用。 <code>release</code>和<code>acquire</code>构成了synchronize-with关系，也就是同步关系。在这个关系下：线程A中所有发生在release x之前的值的写操作， 对线程B的acquire x之后的任何操作都可见。</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">#include <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>atomic<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>cassert<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>

<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>bool<span class="token operator">&gt;</span> ready<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
int data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">sender</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    data <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>                                              <span class="token comment">// A</span>
    <span class="token keyword">var</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// B</span>
    ready<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// C</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">receiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ready<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment">// D</span>
        <span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// never failed                    // E</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">var</span> <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// never failed                    // F</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>sender<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><p>上面的例子中：</p><ul class="ul-level-0"><li>sender线程中<code>data = 42</code>是sequence before原子变量ready的</li><li>sender和receiver在C和D处发生了同步</li><li>线程sender中C之前的所有读写对线程receiver都是可见的 显然， <code>release</code>和<code>acquire</code>组合在一起比<code>release</code>和<code>consume</code>组合更加Strong！</li></ul><h4 id="b9gtg" name="2.4-memory-order-release">2.4 memory order release</h4><p>release order一般不单独使用，它和<code>acquire</code>和<code>consume</code>组成2种独立的内存顺序搭配。</p><p>这里就不用展开啰里啰嗦了。</p><h4 id="6j6q5" name="2.5-memory-order-acq_rel">2.5 memory order acq_rel</h4><p><code>acq_rel</code>是acquire和release的叠加。中文不知道该咋描述好：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;"><span class="token constant">A</span> read<span class="token operator">-</span>modify<span class="token operator">-</span>write operation <span class="token keyword">with</span> <span class="token keyword">this</span> memory order is both an acquire operation and a release operation<span class="token punctuation">.</span> No memory reads or writes <span class="token keyword">in</span> the current thread can be reordered before or after <span class="token keyword">this</span> store<span class="token punctuation">.</span> All writes <span class="token keyword">in</span> other threads that release the same atomic variable are visible before the modification and the modification is visible <span class="token keyword">in</span> other threads that acquire the same atomic variable<span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></div><p>大致意思是：memory_order_acq_rel适用于read-modify-write operation， 对于采用此内存序的read-modify-write operation，我们可以称为acq_rel operation， 既属于acquire operation 也是release operation. 设有一个原子变量M上的acq_rel operation：自然的，该acq_rel operation之前的内存读写都不能重排到该acq_rel operation之后， 该acq_rel operation之后的内存读写都不能重排到该acq_rel operation之前. 其他线程中所有对M的release operation及其之前的写入都对当前线程从该acq_rel operation开始的操作可见， 并且截止到该acq_rel operation的所有内存写入都对另外线程对M的acquire operation以及之后的内存操作可见[13]。</p><p>这里是一个例子，关于为什么要有<code>acq_rel</code>可以参考一下：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">#include <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>atomic<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>cassert<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">&gt;</span>
 
<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> flag <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">thread_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    data<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    flag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">thread_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    int expected<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_acq_rel<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">thread_3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// will never fire</span>
<span class="token punctuation">}</span>
 
int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">a</span><span class="token punctuation">(</span>thread_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">b</span><span class="token punctuation">(</span>thread_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">c</span><span class="token punctuation">(</span>thread_3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><h4 id="i2nn" name="2.6-memory-order-seq_cst">2.6 memory order seq_cst</h4><p><code>seq_cst</code>表示顺序一致性内存模型，在这个模型约束下不仅同一个线程内的执行结果是和程序顺序一致的， 每个线程间互相看到的执行结果和程序顺序也保持顺序一致。显然，<code>seq_cst</code>的约束是最强的，这意味着要牺牲性能为代价。</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">        atomic int <span class="token function">x</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               atomic int <span class="token function">y</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    x<span class="token punctuation">.</span> <span class="token function">store</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> seq cst <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">||</span>      y<span class="token punctuation">.</span> <span class="token function">store</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> seq cst <span class="token punctuation">)</span><span class="token punctuation">;</span>
    int r1 <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span> seq cst <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">||</span>      int r2 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span> seq cst <span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">assert</span> <span class="token punctuation">(</span>r1 <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> r2 <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></div><p>下面是一个seq_cst的实例：</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">#include <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>atomic<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>cassert<span class="token operator">&gt;</span>
 
<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>bool<span class="token operator">&gt;</span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>bool<span class="token operator">&gt;</span> y <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">&gt;</span> z <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">write_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">write_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">read_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">a</span><span class="token punctuation">(</span>write_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">b</span><span class="token punctuation">(</span>write_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">c</span><span class="token punctuation">(</span>read_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">d</span><span class="token punctuation">(</span>read_y_then_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> d<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// will never happen</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><h4 id="67vcb" name="2.7-Relationship-with-volatile">2.7 Relationship with volatile</h4><p>人的一生总是充满了疑惑。</p><p>可能你会思考？volatile关键字能够防止指令被编译器优化，那它能提供线程间(inter-thread)同步语义吗？答案是：不能！！！</p><ul class="ul-level-0"><li>尽管volatile能够防止单个线程内对volatile变量进行reorder，但多个线程同时访问同一个volatile变量，线程间是完全不提供同步保证。</li><li>而且，volatile不提供原子性！</li><li>并发的读写volatile变量是会产生数据竞争的，同时non volatile操作可以在volatile操作附近自由地reorder。</li></ul><p>看一个例子，执行下面的并发程序，不出意外的话，你不会得到一个为0的结果。</p><div class="rno-markdown-code"><div class="rno-markdown-code-toolbar"><div class="rno-markdown-code-toolbar-info"><div class="rno-markdown-code-toolbar-item is-type"><span class="is-m-hidden">代码语言：</span>javascript</div></div><div class="rno-markdown-code-toolbar-opt"><div class="rno-markdown-code-toolbar-copy"><i class="icon-copy"></i><span class="is-m-hidden">复制</span></div></div></div><div class="developer-code-block"><pre class="prism-token token line-numbers language-javascript" tabindex="0"><code class="language-javascript" style="margin-left: 0px;">#include <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span>
#include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>

volatile int count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">decrease</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>increase<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>decrease<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token literal-property property">std</span><span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><h3 id="2n5us" name="3.-Reference">3. Reference</h3><ol class="ol-level-0"><li>The C/C++ Memory Model: Overview and Formalization</li><li>知乎专栏：如何理解C++的6种memory order</li><li>理解 C++ 的 Memory Order</li><li>理解弱内存顺序模型</li><li>当我们在谈论 memory order 的时候，我们在谈论什么</li><li>https://en.cppreference.com/w/cpp/atomic/memory_order</li><li>Youtube: Atomic’s memory orders, what for? - Frank Birbacher [ACCU 2017]</li><li>C++11中的内存模型下篇 - C++11支持的几种内存模型</li><li>memory ordering, Gavin's blog</li><li>c++11 内存模型解读</li><li>memory barriers in c, <a href="https://cloud.tencent.com/product/tdsql?from_column=20065&amp;from=20065" target="_blank" class="rno-markdown__textlink-new" style="color: rgb(0, 82, 217);">MariaDB</a> FOUNDATION, pdf</li><li>C++ memory order循序渐进</li><li>Memory Models for C/C++ Programers</li><li>Memory Consistency Models: A Tutorial</li></ol></div></div></div><div class="mod-content__source"><div class="mod-content__source-inner"><div class="mod-content__source-title">本文参与&nbsp;<a href="https://cloud.tencent.com/developer/support-plan" target="_blank">腾讯云自媒体同步曝光计划</a>，分享自微信公众号。</div><div class="mod-content__source-desc">原始发表：2020-06-01，如有侵权请联系&nbsp;<a href="mailto:cloudcommunity@tencent.com">cloudcommunity@tencent.com</a> 删除</div></div><div class="mod-content__source-qr"></div></div><div class="mod-statement-m"><div class="cdc-tag__list mod-content__tags" track-click=""><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div><div class="mod-content__statement"><p>本文分享自 <span>Linux阅码场</span> 微信公众号，<span style="color: rgb(0, 82, 217);">前往查看</span></p><p>如有侵权，请联系 <a href="mailto:cloudcommunity@tencent.com">cloudcommunity@tencent.com</a> 删除。</p><p class="mod-content__statement-tip">本文参与&nbsp;<a href="https://cloud.tencent.com/developer/support-plan" target="_blank">腾讯云自媒体同步曝光计划</a>&nbsp; ，欢迎热爱写作的你一起参与！</p></div></div><div class="cdc-tag__list mod-content__tags" track-click=""><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div></div></div><div class="mod-article-content is-pill-hidden"><div class="mod-comment"><div class="mod-relevant__title">评论</div><div class="cdc-comment-response is-blank"><div class="cdc-comment-response-single-edit not-logged"><div class="cdc-comment-response-single-edit__inner"><span class="cdc-avatar cdc-comment-response-single-edit__avatar cdc-comment__avatar circle"><span class="cdc-avatar__inner" target="_blank" style="background-image: url(&quot;https://qcloudimg.tencent-cloud.cn/raw/2eca91c9c29816ff056d22815949d83c.png&quot;);"></span></span><div class="cdc-comment-response-single-edit__main"><span>登录</span>后参与评论</div></div></div><div class="cdc-comment-response__toolbar"></div><div class="cdc-comment-response-inner"><div class="cdc-comment-response__body is-blank"><div class="cdc-comment-response__blank"><i class="cdc-comment-response__blank-img"></i><div class="cdc-comment-response__blank-tip">暂无评论</div></div></div></div><div class="cdc-operate-footer"><div class="cdc-operate-footer__inner"><div class="cdc-operate-footer__toggle is-logout"><div class="cdc-operate-footer__toggle-text"><span>登录 </span>后参与评论</div></div></div></div></div></div></div><div class="mod-article-content recommend"><div class="mod-relevant" qct-area="推荐阅读" qct-exposure=""><div class="mod-relevant__title recommend-read">推荐阅读</div><div class="cdc-article-rank" qct-area="编辑精选文章" qct-exposure=""><div class="cdc-article-rank__hd"><div class="cdc-article-rank__title">编辑精选文章</div><div class="cdc-article-rank__refresh">换一批<i class="icon-refresh"></i></div></div><div class="cdc-article-rank__bd"><div class="t-row t-row--start t-row--top" style="margin-left: -25px; margin-right: -25px; row-gap: 16px;"><div class="t-col t-col-6 t-col-offset-0 t-col-pull-0 t-col-push-0 t-col-order-0" style="padding-left: 25px; padding-right: 25px;"><a class="cdc-article-rank__item" href="https://cloud.tencent.com/developer/article/2396194" target="_blank" qct-area="文章-2396194" qct-click="" qct-exposure=""><i class="icon-article"></i><span class="cdc-article-rank__item-title">眼看他搭中台，眼看他又拆了</span><div class="cdc-article-rank__item-view"><i class="icon-view"></i>13507</div></a></div><div class="t-col t-col-6 t-col-offset-0 t-col-pull-0 t-col-push-0 t-col-order-0" style="padding-left: 25px; padding-right: 25px;"><a class="cdc-article-rank__item" href="https://cloud.tencent.com/developer/article/2396572" target="_blank" qct-area="文章-2396572" qct-click="" qct-exposure=""><i class="icon-article"></i><span class="cdc-article-rank__item-title">QQ 25年技术巡礼丨技术探索下的清新设计，打造轻盈简约的QQ9</span><div class="cdc-article-rank__item-view"><i class="icon-view"></i>1715</div></a></div><div class="t-col t-col-6 t-col-offset-0 t-col-pull-0 t-col-push-0 t-col-order-0" style="padding-left: 25px; padding-right: 25px;"><a class="cdc-article-rank__item" href="https://cloud.tencent.com/developer/article/2318306" target="_blank" qct-area="文章-2318306" qct-click="" qct-exposure=""><i class="icon-article"></i><span class="cdc-article-rank__item-title">【万字长文】论如何构建一个资金账户系统 | 技术创作特训营第一期</span><div class="cdc-article-rank__item-view"><i class="icon-view"></i>4305</div></a></div><div class="t-col t-col-6 t-col-offset-0 t-col-pull-0 t-col-push-0 t-col-order-0" style="padding-left: 25px; padding-right: 25px;"><a class="cdc-article-rank__item" href="https://cloud.tencent.com/developer/article/2384568" target="_blank" qct-area="文章-2384568" qct-click="" qct-exposure=""><i class="icon-article"></i><span class="cdc-article-rank__item-title">因为一部遮天，我用三种语言实现了腾讯国漫评分系统</span><div class="cdc-article-rank__item-view"><i class="icon-view"></i>4000</div></a></div><div class="t-col t-col-6 t-col-offset-0 t-col-pull-0 t-col-push-0 t-col-order-0" style="padding-left: 25px; padding-right: 25px;"><a class="cdc-article-rank__item" href="https://cloud.tencent.com/developer/article/2352092" target="_blank" qct-area="文章-2352092" qct-click="" qct-exposure=""><i class="icon-article"></i><span class="cdc-article-rank__item-title">得物 Redis 设计与实践</span><div class="cdc-article-rank__item-view"><i class="icon-view"></i>3128</div></a></div><div class="t-col t-col-6 t-col-offset-0 t-col-pull-0 t-col-push-0 t-col-order-0" style="padding-left: 25px; padding-right: 25px;"><a class="cdc-article-rank__item" href="https://cloud.tencent.com/developer/article/2351935" target="_blank" qct-area="文章-2351935" qct-click="" qct-exposure=""><i class="icon-article"></i><span class="cdc-article-rank__item-title">【万字长文】K8s部署前后端分离web应用避坑指南之一：从源代码到docker compose到k8s云集群（macOS-2023版）</span><div class="cdc-article-rank__item-view"><i class="icon-view"></i>5314</div></a></div></div></div></div><div class="mod-relevant__list" qct-area="相关文章"><div class="cdc-article-panel-response__list"><div class="cdc-article-panel-response" qct-area="文章-2120357" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2120357" target="_blank" class="cdc-article-panel-response__title">深入理解C11/C++11内存模型(白嫖新知识~)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2120357" target="_blank">现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这是多处理器架构下并发编程里必须掌握的一个基础概念。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/10025783" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-10025783/f944dfc5449517953be67757d24bdb1e.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">嵌入式Linux内核</div></div><div class="cdc-article-panel-response__date">2022-09-23</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">332</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/d4c0737723281ac9427e81b4b0e9552a.jpg" alt="深入理解C11/C++11内存模型(白嫖新知识~)"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2026043" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2026043" target="_blank" class="cdc-article-panel-response__title">聊聊内存模型和内存序</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10278" target="_blank">ide</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2026043" target="_blank">最近群里聊到了Memory Order相关知识，恰好自己对这块的理解是模糊的、无序的，所以借助本文，重新整理下相关知识。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/8315663" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-8315663/bfa38fa4d7a0aa224c9b7c085eb574fa.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">高性能架构探索</div></div><div class="cdc-article-panel-response__date">2022-06-17</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">2.3K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">1</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1765696" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1765696" target="_blank" class="cdc-article-panel-response__title">What is the Memory Model in C++11</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1765696" target="_blank">C++11其实主要就四方面内容，第一个是可变参数模板，第二个是右值引用，第三个是智能指针，第四个是内存模型（Memory Model）。
</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/5907296" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-5907296/vxavo43gpc.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">C语言与CPP编程</div></div><div class="cdc-article-panel-response__date">2020-12-28</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">393</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/p4e2k3shnt.jpeg" alt="What is the Memory Model in C++11"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1886297" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1886297" target="_blank" class="cdc-article-panel-response__title">C++ 内存模型</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10278" target="_blank">ide</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10813" target="_blank">https</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10681" target="_blank">网络安全</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1886297" target="_blank">在《C++ 并发编程》一文中，我们已经介绍了C++11到C++17在并发编程方面的新增API。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/5907296" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-5907296/vxavo43gpc.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">C语言与CPP编程</div></div><div class="cdc-article-panel-response__date">2021-10-09</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">2.2K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1942213" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1942213" target="_blank" class="cdc-article-panel-response__title">C++11内存模型</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10670" target="_blank">缓存</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/125" target="_blank">其他</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1942213" target="_blank">最近看了极客时间——《现代C++实战三十讲》中的内存模型与Atomic一节，感觉对C++的内存模型理解还不是很清楚，看了后面的参考文献以及看了一些好的博客，算是基本了解了，根据参考文献整合一下。更多细节可以看看参考文献。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1131975" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-1131975/0cd84137e3dbac4858106ecbf3ddc424.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">ClearSeve</div></div><div class="cdc-article-panel-response__date">2022-02-11</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">745</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/74ccb7f8876d1e8499ef5b4934760981.png" alt="C++11内存模型"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2327894" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2327894" target="_blank" class="cdc-article-panel-response__title">ARMv8 内存系统学习笔记</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/16248" target="_blank">std</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17382" target="_blank">内存</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17506" target="_blank">系统</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17508" target="_blank">线程</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17534" target="_blank">学习笔记</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2327894" target="_blank">Normal memory 可以设置为 cacheable 或 non-cacheable，可以按 inner 和 outer 分别设置。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1392766" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/avatar/1392766/iiy5fo9f7q.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">刘盼</div></div><div class="cdc-article-panel-response__date">2023-09-11</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">312</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/310078b32b5f8d377afe1c9edec9b513.jpg" alt="ARMv8 内存系统学习笔记"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2310832" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2310832" target="_blank" class="cdc-article-panel-response__title">《C++并发编程实战》读书笔记（3）：内存模型和原子操作</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17198" target="_blank">并发编程</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17246" target="_blank">读书笔记</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17381" target="_blank">模型</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17382" target="_blank">内存</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2310832" target="_blank"> C++标准中对象定义为某一存储范围。每个变量都是对象，每个对象都占用至少一块内存区域，若变量属于内建基本类型则仅占用一块，相邻的位域属于同一块。
</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/5907296" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-5907296/vxavo43gpc.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">C语言与CPP编程</div></div><div class="cdc-article-panel-response__date">2023-08-10</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">246</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/3e369b6d567b9043799a56cdb81c3553.jpg" alt="《C++并发编程实战》读书笔记（3）：内存模型和原子操作"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1990477" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1990477" target="_blank" class="cdc-article-panel-response__title">蓝桥ROS机器人之现代C++学习笔记7.5 内存模型</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17381" target="_blank">模型</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/17382" target="_blank">内存</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1990477" target="_blank">学习代码如下：
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace std::chrono;

const int N = 10000;

void relaxed_order() {
    cout &lt;&lt; "relaxed_order: " &lt;&lt; endl;

    atomic&lt;int&gt; counter = {0};
    ve</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/3350419" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-3350419/f6454cee38969641dfa1c545f073df40.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">zhangrelay</div></div><div class="cdc-article-panel-response__date">2022-04-29</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">192</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/8e94abb57fa83ec37be0747fe3ef6df0.png" alt="蓝桥ROS机器人之现代C++学习笔记7.5 内存模型"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1173689" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1173689" target="_blank" class="cdc-article-panel-response__title">C++ 新特性学习（八） — 原子操作和多线程库[多工内存模型]</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/125" target="_blank">其他</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1173689" target="_blank">分别对于两个进程而言，可观察行为确实没有变化。而这种优化在某些时候确实会有比较明显的效果。但是很显然，语义变化了。在原来的结果里不可能发生 x和y都为0的情况，而优化过后，有可能出现。
 再来个例子：</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1144827" target="_blank" style="background-image: url(&quot;https://developer.qcloudimg.com/http-save/10011/55ff304933446eb93a434bc612dcd0e7.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">owent</div></div><div class="cdc-article-panel-response__date">2018-08-01</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">418</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1933082" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1933082" target="_blank" class="cdc-article-panel-response__title">[译]C++中的内存同步模式(memory order)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1933082" target="_blank">原子变量同步是内存模型中最让人感到困惑的地方.原子(atomic)变量的主要作用就是同步多线程间的共享内存访问,一般来讲,某个线程会创建一些数据,然后给原子变量设置标志数值(译注:此处的原子变量类似于一个flag);其他线程则读取这个原子变量,当发现其数值变为了标志数值之后,之前线程中的共享数据就应该已经创建完成并且可以在当前线程中进行读取了.不同的内存同步模式标识了线程间数据共享机制的"强弱"程度,富有经验的程序员可以使用"较弱"的同步模式来提高程序的执行效率.</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/2615200" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/avatar/2615200/st70tpw9j7.png&quot;);"></a></span><div class="cdc-article-panel-response__user-name">用户2615200</div></div><div class="cdc-article-panel-response__date">2022-01-12</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">1.1K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2233477" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2233477" target="_blank" class="cdc-article-panel-response__title">C++ 新特性学习（八） — 原子操作和多线程库[多工内存模型]</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10812" target="_blank">数据结构</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10275" target="_blank">打包</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2233477" target="_blank">分别对于两个进程而言，可观察行为确实没有变化。而这种优化在某些时候确实会有比较明显的效果。但是很显然，语义变化了。在原来的结果里不可能发生 x和y都为0的情况，而优化过后，有可能出现。 再来个例子：</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1144827" target="_blank" style="background-image: url(&quot;https://developer.qcloudimg.com/http-save/10011/55ff304933446eb93a434bc612dcd0e7.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">owent</div></div><div class="cdc-article-panel-response__date">2023-03-05</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">280</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1994391" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1994391" target="_blank" class="cdc-article-panel-response__title">c++11单实例(singleton)初始化的几种方法(memory fence,atomic,call_once)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10308" target="_blank">linux</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10705" target="_blank">面向对象编程</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1994391" target="_blank">单实例模式(singleton)下要求一个类只能有一个实例,如何保证只创建一个实例？类的静态成员延迟初始化要求静态成员只能被初始化一次，也有类似的问题。 
 在单线程环境下，这事儿很好办。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1148648" target="_blank" style="background-image: url(&quot;https://developer.qcloudimg.com/http-save/10011/3234b0c36695fce0b14d93a5064a1d70.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">10km</div></div><div class="cdc-article-panel-response__date">2022-05-07</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">774</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1630920" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1630920" target="_blank" class="cdc-article-panel-response__title">​C++ memory order 勘误</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1630920" target="_blank">大约半年前写了一篇 C++11 memory order，有一定数量的人看过，尽管其中大部分内容无误，不过复查发现一些描述不准确或者不妥当的地方，而微信文章又不能修改 20 字以上，为避免传讹，想想还是把之前的文章删掉了。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/4618319" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/random-avatar/4618319/z7owr5eyr8.png&quot;);"></a></span><div class="cdc-article-panel-response__user-name">JIFF</div></div><div class="cdc-article-panel-response__date">2020-05-20</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">688</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2026572" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2026572" target="_blank" class="cdc-article-panel-response__title">【Example】C++ 标准库 std::atomic 及 std::memory_order</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2026572" target="_blank">原子操作是多线程当中对资源进行保护的一种手段，主要作用是和互斥量(Mutex)一样，避免对资源的并发访问、修改。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/6253003" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-6253003/8a75f4083af5ccf84af5f2c99b91452c.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">芯片烤电池</div></div><div class="cdc-article-panel-response__date">2022-06-20</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">666</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1432683" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1432683" target="_blank" class="cdc-article-panel-response__title">c++11多线程笔记</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1432683" target="_blank">1 thread类
thread f;
线程等待join()
线程分离detach()</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1117071" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/avatar/male/BJuxanbSdm.png&quot;);"></a></span><div class="cdc-article-panel-response__user-name">幂</div></div><div class="cdc-article-panel-response__date">2019-05-25</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">492</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1660982" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1660982" target="_blank" class="cdc-article-panel-response__title">内存顺序（Memory Order）问题（一）</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10278" target="_blank">ide</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1660982" target="_blank">内存顺序，通俗地讲，是关于代码编译成机器指令后的执行顺序问题。内存顺序和编译器、硬件架构密切相关。那为什么会产生内存顺序问题呢？有两方面原因： 一方面，编译器为了优化程序性能，不会完全按照开发者写的代码的顺序来生成机器指令； 另一方面，在程序运行时，为了提高性能，CPU也不完全按照程序的指令顺序执行，比如体系结构里经典的Tomasulo算法。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/7492196" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/random-avatar/7492196/y4xad6qazw.png&quot;);"></a></span><div class="cdc-article-panel-response__user-name">王璞</div></div><div class="cdc-article-panel-response__date">2020-07-14</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">2.3K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1403223" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1403223" target="_blank" class="cdc-article-panel-response__title">C和C++中的volatile、内存屏障和CPU缓存一致性协议MESI</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1403223" target="_blank"> 	然后看看标准C++基金会（https://isocpp.org）怎么说的（官方链接）： </a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/1071314" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/avatar/1071314/s6xdq6us7n.png&quot;);"></a></span><div class="cdc-article-panel-response__user-name">一见</div></div><div class="cdc-article-panel-response__date">2019-03-14</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">3.5K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/ybh32aexkh.png" alt="C和C++中的volatile、内存屏障和CPU缓存一致性协议MESI"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2033942" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2033942" target="_blank" class="cdc-article-panel-response__title">关于原子变量的一些事情</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10670" target="_blank">缓存</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2033942" target="_blank">我们可以保证打印的global一定是2*20000000吗？答案是否定的。那为什么呢？</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/3485742" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/developer-images/custom-avatar/3485742/d0c4g6kzfe.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">JohnYao</div></div><div class="cdc-article-panel-response__date">2022-06-29</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">270</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/ef8e1328e0f1576b91c81a1702b21998.jpeg" alt="关于原子变量的一些事情"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2168307" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2168307" target="_blank" class="cdc-article-panel-response__title">【笔记】《深入理解C++11》(下)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10813" target="_blank">https</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10681" target="_blank">网络安全</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10278" target="_blank">ide</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10275" target="_blank">打包</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/2168307" target="_blank">本篇是看完《深入理解C++11：C++11新特性解析与应用》后做的笔记的下半部分. 这本书可以看作是《C++Primer》的进阶版, 主要是更加详细地介绍了C++11的一些常用设计和标准库设施, 很多知识点都在面试中会遇到, 值得一读.</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/7604580" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-7604580/jbuyxz791x.jpeg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">ZifengHuang</div></div><div class="cdc-article-panel-response__date">2022-11-18</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">1K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/86c7530fb74c8469f3482dbd9d285307.jpg" alt="【笔记】《深入理解C++11》(下)"></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1005903" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1005903" target="_blank" class="cdc-article-panel-response__title">当我们在谈论 memory order 的时候，我们在谈论什么</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-tag-links cdc-article-panel-response__tags"><i class="cdc-tag-links__icon"></i><div class="cdc-tag-links__items"><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10166" target="_blank">c++</a><a class="cdc-tag-links__item" href="https://cloud.tencent.com/developer/tag/10663" target="_blank">编程算法</a></div></div><div class="cdc-article-panel-response__media"><a class="cdc-article-panel-response__desc" href="https://cloud.tencent.com/developer/article/1005903" target="_blank">该文介绍了如何利用C++ 11新特性在程序中引入memory order，从而确保数据在多线程环境中正确性和性能。作者详细介绍了memory order的概念以及C++ 11中提供的两种memory order：memory_order_seq_cst和memory_order_acquire。文章还讨论了在多线程环境中出现的一些问题，例如：memory fence、memory barrier、relaxed memory order等，并给出了示例代码以说明如何使用C++ 11的新特性来避免这些问题。</a></div><div class="cdc-article-panel-response__infos"><div class="cdc-article-panel-response__user"><span class="cdc-avatar large cdc-article-panel-response__user-avatar circle"><a class="cdc-avatar__inner" href="https://cloud.tencent.com/developer/user/839405" target="_blank" style="background-image: url(&quot;https://ask.qcloudimg.com/http-save/yehe-839405/8f4fb9f1cce4405cc714ddd1be554c1d.jpg&quot;);"></a></span><div class="cdc-article-panel-response__user-name">serena</div></div><div class="cdc-article-panel-response__date">2017-09-12</div><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">4K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">4</span></span></div></div></div><div class="cdc-article-panel-response__object"><img class="cdc-article-panel-response__object-thumbnail" src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/327a20640bfee8663f8905490850f366.png" alt="当我们在谈论 memory order 的时候，我们在谈论什么"></div></div></div></div></div></div></div><div class="mod-recommend"><div class="mod-recommend__title">推荐阅读</div><div class="mod-recommend__topic"><div class="mod-recommend__topic-list"><div class="cdc-m-article-rank" qct-area="编辑精选文章" qct-exposure=""><div class="cdc-m-article-rank__hd"><div class="cdc-m-article-rank__title">编辑精选文章</div></div><div class="cdc-m-article-rank__bd"><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/article/2385781" qct-area="编辑精选-2385781" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">我独到的技术见解--大型前端项目的常见问题和解决方案</span></a><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/article/2387530" qct-area="编辑精选-2387530" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">亿级大表冷热分级的工程实践</span></a><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/article/2395421" qct-area="编辑精选-2395421" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">Design2Code：前端离失业还有多远</span></a></div></div><div class="cdc-m-article-rank" qct-area="相关讨论" qct-exposure=""><div class="cdc-m-article-rank__hd"><div class="cdc-m-article-rank__title">相关讨论</div></div><div class="cdc-m-article-rank__bd"><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/ask/257669" qct-area="相关-257669" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">内存泄漏的定位与排查：Heap Profiling 原理解析？</span></a><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/ask/318098" qct-area="相关-318098" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">关于题目的理解？</span></a><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/ask/177538" qct-area="相关-177538" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">怎么理解腾讯云？</span></a></div></div><div class="cdc-m-article-rank" qct-area="相关课程" qct-exposure=""><div class="cdc-m-article-rank__hd"><div class="cdc-m-article-rank__title">相关课程</div></div><div class="cdc-m-article-rank__bd"><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/learning/graph/8" qct-area="相关-8" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">前端</span></a><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/learning/camp/17" qct-area="相关-17" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">Python教程-Django框架快速入门到实战</span></a><a class="cdc-m-article-rank__item" href="https://cloud.tencent.com/developer/learning/graph/6" qct-area="相关-6" qct-click="" qct-exposure=""><i class="cdc-m-article-rank__item-icon"></i><span class="cdc-m-article-rank__item-title">C/Python</span></a></div></div></div></div><div class="mod-recommend__list" qct-area="相关文章" qct-exposure=""><div class="cdc-article-panel-response__list"><div class="cdc-article-panel-response" qct-area="文章-2120357" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2120357" target="_blank" class="cdc-article-panel-response__title">深入理解C11/C++11内存模型(白嫖新知识~)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">332</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2026043" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2026043" target="_blank" class="cdc-article-panel-response__title">聊聊内存模型和内存序</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">2.3K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">1</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1765696" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1765696" target="_blank" class="cdc-article-panel-response__title">What is the Memory Model in C++11</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">393</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div></div><div class="mod-recommend__product"><div class="mod-recommend__product-list"><div class="cdc-new-product-info2 is-card is-single"><div class="cdc-new-product-info2-inner"><div class="cdc-new-product-info2-main"><div class="cdc-new-product-info2-title">云数据库 MariaDB</div><div class="cdc-new-product-info2-btns"><button class="cdc-btn cdc-new-product-info2-btns-introduce cdc-btn--hole"><a href="https://cloud.tencent.com/product/tdsql?from=21341&amp;from_column=21341">产品介绍</a></button><button class="cdc-btn cdc-btn--hole"><a href="https://cloud.tencent.com/document/product/237?from=21342&amp;from_column=21342">产品文档</a></button></div></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1886297" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1886297" target="_blank" class="cdc-article-panel-response__title">C++ 内存模型</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">2.2K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1942213" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1942213" target="_blank" class="cdc-article-panel-response__title">C++11内存模型</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">745</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2327894" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2327894" target="_blank" class="cdc-article-panel-response__title">ARMv8 内存系统学习笔记</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">312</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2310832" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2310832" target="_blank" class="cdc-article-panel-response__title">《C++并发编程实战》读书笔记（3）：内存模型和原子操作</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">246</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-event-card with-tag"><span class="cdc-event-card__tag orange" track-click="{&quot;elementId&quot;:1}">广告</span><div track-click="{&quot;elementId&quot;:2}" class="cdc-event-card__close"></div><div class="cdc-event-card__inner"><div class="cdc-event-card__object" track-click="{&quot;elementId&quot;:3}"><div class="cdc-event-card__object-image" style="background-image: url(&quot;https://developer.qcloudimg.com/operation/attachment/900005/20240423-be5d94ed.png&quot;);"></div></div><div class="cdc-event-card__detail"><div class="cdc-event-card__title" track-click="{&quot;elementId&quot;:4}">专栏持续上新-竞品课程 免费学习</div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1990477" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1990477" target="_blank" class="cdc-article-panel-response__title">蓝桥ROS机器人之现代C++学习笔记7.5 内存模型</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">192</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1173689" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1173689" target="_blank" class="cdc-article-panel-response__title">C++ 新特性学习（八） — 原子操作和多线程库[多工内存模型]</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">418</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1933082" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1933082" target="_blank" class="cdc-article-panel-response__title">[译]C++中的内存同步模式(memory order)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">1.1K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2233477" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2233477" target="_blank" class="cdc-article-panel-response__title">C++ 新特性学习（八） — 原子操作和多线程库[多工内存模型]</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">280</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1994391" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1994391" target="_blank" class="cdc-article-panel-response__title">c++11单实例(singleton)初始化的几种方法(memory fence,atomic,call_once)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">774</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1630920" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1630920" target="_blank" class="cdc-article-panel-response__title">​C++ memory order 勘误</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">688</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2026572" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2026572" target="_blank" class="cdc-article-panel-response__title">【Example】C++ 标准库 std::atomic 及 std::memory_order</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">666</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1432683" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1432683" target="_blank" class="cdc-article-panel-response__title">c++11多线程笔记</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">492</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1660982" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1660982" target="_blank" class="cdc-article-panel-response__title">内存顺序（Memory Order）问题（一）</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">2.3K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1403223" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1403223" target="_blank" class="cdc-article-panel-response__title">C和C++中的volatile、内存屏障和CPU缓存一致性协议MESI</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">3.5K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2033942" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2033942" target="_blank" class="cdc-article-panel-response__title">关于原子变量的一些事情</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">270</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-2168307" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/2168307" target="_blank" class="cdc-article-panel-response__title">【笔记】《深入理解C++11》(下)</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">1K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">0</span></span></div></div></div></div></div><div class="cdc-article-panel-response" qct-area="文章-1005903" qct-click="" qct-exposure=""><a href="https://cloud.tencent.com/developer/article/1005903" target="_blank" class="cdc-article-panel-response__title">当我们在谈论 memory order 的时候，我们在谈论什么</a><div class="cdc-article-panel-response__inner"><div class="cdc-article-panel-response__main"><div class="cdc-article-panel-response__media"></div><div class="cdc-article-panel-response__infos"><div class="cdc-icon__list cdc-article-panel-response__operate"><span class="cdc-icon"><i class="icon-view"></i><span class="cdc-icon__number">4K</span></span><span class="cdc-icon"><i class="icon-ask"></i><span class="cdc-icon__number">4</span></span></div></div></div></div></div></div></div></div><div class="cdc-layout__side"><div class="cdc-personal-info2 mod-author"><div class="cdc-personal-info2__inner"><div class="cdc-personal-info2__detail"><div class="cdc-personal-info2__main"><div class="cdc-personal-info2__name"><a href="https://cloud.tencent.com/developer/user/5465588" target="_blank" class="cdc-personal-info2__name-text">Linux阅码场</a>0</div><div class="cdc-personal-info2__level"><div class="cdc-personal-info2__level-number">LV.0</div><div class="cdc-emblems cdc-personal-info2__level-emblems"></div></div><div class="cdc-personal-info2__position"></div></div><div class="cdc-personal-info2__avatar"><span class="cdc-avatar xlarge circle" style="cursor: pointer;"><span class="cdc-avatar__inner" style="background-image: url(&quot;https://ask.qcloudimg.com/random-avatar/5465588/kn484luc7w.png&quot;);"></span><button class="cdc-btn cdc-avatar__btn cdc-btn--hole"><i class="icon-add"></i>关注</button></span></div></div><div class="cdc-personal-info2__list"><a class="cdc-personal-info2__item" href="https://cloud.tencent.com/developer/user/5465588/articles" target="_blank"><div class="cdc-personal-info2__item-text">文章</div><div class="cdc-personal-info2__item-number">366</div></a><a class="cdc-personal-info2__item" href="https://cloud.tencent.com/developer/user/5465588" target="_blank"><div class="cdc-personal-info2__item-text">获赞</div><div class="cdc-personal-info2__item-number">1K</div></a><a href="https://cloud.tencent.com/developer/column/77185" class="cdc-personal-info2__item" target="_blank"><div class="cdc-personal-info2__item-text">专栏</div><div class="cdc-personal-info2__item-number">1</div></a></div><div class="cdc-personal-info2__recommend"><div class="cdc-personal-info2__recommend-hd"><div class="cdc-personal-info2__recommend-title"><i class="icon-choice"></i>作者相关精选</div><div class="cdc-personal-info2__recommend-change">换一批<i class="icon-change"></i></div></div><div class="cdc-personal-info2__recommend-bd"><ul class="cdc-personal-info2__recommend-list"><li><a href="https://cloud.tencent.com/developer/article/2389938" class="cdc-personal-info2__recommend-item" target="_blank"><i class="icon-article"></i><span class="cdc-personal-info2__recommend-text">Linux内核中的各种锁：信号量/互斥锁/读写锁/原子锁/自旋锁/内存屏障等</span></a></li><li><a href="https://cloud.tencent.com/developer/article/2127043" class="cdc-personal-info2__recommend-item" target="_blank"><i class="icon-article"></i><span class="cdc-personal-info2__recommend-text">深入理解Linux电源管理</span></a></li><li><a href="https://cloud.tencent.com/developer/article/1901775" class="cdc-personal-info2__recommend-item" target="_blank"><i class="icon-article"></i><span class="cdc-personal-info2__recommend-text">Linux中的spinlock机制 - CAS和ticket spinlock</span></a></li></ul></div></div></div></div><div class="mod-sticky-act" style="top: 126px;"><div class="cdc-directory"><div class="cdc-directory__wrap"><div class="cdc-directory__inner"><div class="cdc-directory__hd">目录</div><div class="cdc-directory__bd"><div class="cdc-directory__bd-box"><ul class="cdc-directory__list level-1"><li class="cdc-directory__item is-active"><span class="cdc-directory__target" id="menu-76k1h">happens-before</span></li><li class="cdc-directory__item"><span class="cdc-directory__target" id="menu-b7jtr">2.3 memory order acquire</span></li><li class="cdc-directory__item"><span class="cdc-directory__target" id="menu-b9gtg">2.4 memory order release</span></li><li class="cdc-directory__item"><span class="cdc-directory__target" id="menu-6j6q5">2.5 memory order acq_rel</span></li><li class="cdc-directory__item"><span class="cdc-directory__target" id="menu-i2nn">2.6 memory order seq_cst</span></li><li class="cdc-directory__item"><span class="cdc-directory__target" id="menu-67vcb">2.7 Relationship with volatile</span></li><li class="cdc-directory__item"><span class="cdc-directory__target" id="menu-2n5us">3. Reference</span></li></ul></div></div></div><div class="cdc-directory__wrap-shade"></div></div></div><div class="cdc-commercial-card mod-group-card" track-click="{&quot;areaId&quot;:1002,&quot;objectType&quot;:&quot;ad&quot;}" track-exposure="{&quot;areaId&quot;:1002,&quot;objectType&quot;:&quot;ad&quot;}"><div><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/789ec94e-0358-4d12-a5ca-0c7ec3478c14.png" class="cdc-commercial-card__img"></div><div class="cdc-commercial-card__close"></div></div><div class="cdc-commercial-card" track-click="{&quot;areaId&quot;:1002,&quot;objectId&quot;:1431,&quot;objectType&quot;:&quot;ad&quot;}" track-exposure="{&quot;areaId&quot;:1002,&quot;objectId&quot;:1431,&quot;objectType&quot;:&quot;ad&quot;}"><a href="https://cloudstudio.net/columns?channel=ad_tcloud_202404023" target="_blank"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/20240423-485d9a6a.png" class="cdc-commercial-card__img"></a><div class="cdc-commercial-card__tag">广告</div><div class="cdc-commercial-card__close"></div></div><div class="cdc-mod-product2" style="display: block;"><div track-click="" track-exposure="" class="cdc-card"><div class="cdc-card__inner"><div class="cdc-card__hd"><div class="cdc-card__title">相关产品与服务</div></div><div class="cdc-card__bd"><div class="cdc-product-info2__list"><div class="cdc-product-info2"><div class="cdc-product-info2__card-main"><div class="cdc-product-info2__card-name">云数据库 MariaDB</div><div class="cdc-product-info2__card-desc">腾讯云数据库 MariaDB（TencentDB for MariaDB） 让您轻松在云端部署、使用 MariaDB 数据库。MariaDB 是在 MySQL 版权被 Oracle 收购后，由 MySQL 创始人 Monty 创立，其版权授予了“MariaDB基金会（非营利性组织）”以保证 MariaDB 永远开源，良好的开源策略，是企业级应用的最优选择，主流开源社区系统/软件的数据库系统，均已默认配置 MariaDB。</div><div class="cdc-product-info2__card-list"><a target="_blank" href="https://cloud.tencent.com/product/tdsql?from=21341&amp;from_column=21341"><i class="product-icon introduce-icon"></i>产品介绍</a><a target="_blank" href="https://cloud.tencent.com/document/product/237?from=21342&amp;from_column=21342"><i class="product-icon document-icon"></i>产品文档</a></div></div></div></div></div></div></div></div><div class="cdc-discussion-card" style="display: block;"><div class="cdc-discussion-card__inner"><div class="cdc-discussion-card__hd"><div class="cdc-discussion-card__hd-title">加入讨论</div><a href="https://cloud.tencent.com/developer/ask" target="_blank" class="cdc-discussion-card__hd-link"><i class="icon-topic"></i>的问答专区 &gt;</a></div><div class="cdc-discussion-card__detail" track-exposure="{&quot;areaId&quot;:106015,&quot;objectId&quot;:1934780,&quot;recPolicyId&quot;:1001}"><div class="cdc-discussion-card__avatar"><span class="cdc-avatar circle" style="cursor: pointer;"><span class="cdc-avatar__inner" style="background-image: url(&quot;https://ask.qcloudimg.com/avatar/male/HkvxUY6-Hu7.png&quot;);"></span></span></div><div class="cdc-discussion-card__main"><div class="cdc-discussion-card__name"><a href="https://cloud.tencent.com/developer/user/1934780" target="_blank" class="cdc-discussion-card__name-text" track-click="{&quot;areaId&quot;:106015,&quot;objectId&quot;:1934780,&quot;recPolicyId&quot;:1001}">RAkira</a>0</div></div><div class="cdc-discussion-card__btn"><button class="cdc-btn cdc-btn--hole">提问</button></div></div><div class="cdc-discussion-card__recommend"><ul class="cdc-discussion-card__recommend-list"><li class="cdc-discussion-card__recommend-item" track-exposure="{&quot;areaId&quot;:106016,&quot;positionId&quot;:0,&quot;objectId&quot;:257669,&quot;recPolicyId&quot;:1001}"><a class="cdc-discussion-card__recommend-topic" href="https://cloud.tencent.com/developer/ask/257669" target="_blank" track-click="{&quot;areaId&quot;:106016,&quot;positionId&quot;:0,&quot;objectId&quot;:257669,&quot;recPolicyId&quot;:1001}"><i class="icon-discuss"></i><span class="cdc-discussion-card__recommend-text">内存泄漏的定位与排查：Heap Profiling 原理解析？</span></a></li><li class="cdc-discussion-card__recommend-item" track-exposure="{&quot;areaId&quot;:106016,&quot;positionId&quot;:1,&quot;objectId&quot;:318098,&quot;recPolicyId&quot;:1001}"><a class="cdc-discussion-card__recommend-topic" href="https://cloud.tencent.com/developer/ask/318098" target="_blank" track-click="{&quot;areaId&quot;:106016,&quot;positionId&quot;:1,&quot;objectId&quot;:318098,&quot;recPolicyId&quot;:1001}"><i class="icon-discuss"></i><span class="cdc-discussion-card__recommend-text">关于题目的理解？</span></a></li><li class="cdc-discussion-card__recommend-item" track-exposure="{&quot;areaId&quot;:106016,&quot;positionId&quot;:2,&quot;objectId&quot;:177538,&quot;recPolicyId&quot;:1001}"><a class="cdc-discussion-card__recommend-topic" href="https://cloud.tencent.com/developer/ask/177538" target="_blank" track-click="{&quot;areaId&quot;:106016,&quot;positionId&quot;:2,&quot;objectId&quot;:177538,&quot;recPolicyId&quot;:1001}"><i class="icon-discuss"></i><span class="cdc-discussion-card__recommend-text">怎么理解腾讯云？</span></a></li></ul></div></div></div><div class="cdc-free-course-card" style="display: block;"><div class="cdc-free-course-card__inner"><div class="cdc-free-course-card__hd"><div class="cdc-free-course-card__hd-title">相关课程</div><a href="https://cloud.tencent.com/developer/learning" class="cdc-free-course-card__hd-link" target="_blank"><i class="icon-topic"></i>一站式学习中心 &gt;</a></div><div class="cdc-free-course-card__detail"><div class="cdc-free-course-card__detail-item"><a href="https://cloud.tencent.com/developer/learning/graph/8" class="cdc-free-course-card__detail-main" target="_blank" track-click="{&quot;areaId&quot;:106017,&quot;positionId&quot;:0,&quot;objectId&quot;:8,&quot;recPolicyId&quot;:1001}" track-exposure="{&quot;areaId&quot;:106017,&quot;positionId&quot;:0,&quot;objectId&quot;:8,&quot;recPolicyId&quot;:1001}"><div class="cdc-free-course-card__detail-icon"><i class="icon-course"></i></div><div class="cdc-free-course-card__detail-info"><div class="cdc-free-course-card__detail-name">前端</div><div class="cdc-free-course-card__detail-num"><i class="icon-join"></i>847人在学</div></div></a><div class="cdc-tag__list cdc-free-course-card__detail-tags" track-click=""><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/17397" target="_blank">前端</a></div></div></div><div class="cdc-free-course-card__detail-item"><a href="https://cloud.tencent.com/developer/learning/camp/17" class="cdc-free-course-card__detail-main" target="_blank" track-click="{&quot;areaId&quot;:106017,&quot;positionId&quot;:1,&quot;objectId&quot;:17,&quot;recPolicyId&quot;:1001}" track-exposure="{&quot;areaId&quot;:106017,&quot;positionId&quot;:1,&quot;objectId&quot;:17,&quot;recPolicyId&quot;:1001}"><div class="cdc-free-course-card__detail-icon"><i class="icon-course"></i></div><div class="cdc-free-course-card__detail-info"><div class="cdc-free-course-card__detail-name">Python教程-Django框架快速入门到实战</div><div class="cdc-free-course-card__detail-num"><i class="icon-join"></i>612人在学</div></div></a><div class="cdc-tag__list cdc-free-course-card__detail-tags" track-click=""><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/110" target="_blank">对象存储</a></div><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10169" target="_blank">python</a></div><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/17342" target="_blank">开源框架</a></div></div></div><div class="cdc-free-course-card__detail-item"><a href="https://cloud.tencent.com/developer/learning/graph/6" class="cdc-free-course-card__detail-main" target="_blank" track-click="{&quot;areaId&quot;:106017,&quot;positionId&quot;:2,&quot;objectId&quot;:6,&quot;recPolicyId&quot;:1001}" track-exposure="{&quot;areaId&quot;:106017,&quot;positionId&quot;:2,&quot;objectId&quot;:6,&quot;recPolicyId&quot;:1001}"><div class="cdc-free-course-card__detail-icon"><i class="icon-course"></i></div><div class="cdc-free-course-card__detail-info"><div class="cdc-free-course-card__detail-name">C/Python</div><div class="cdc-free-course-card__detail-num"><i class="icon-join"></i>463人在学</div></div></a><div class="cdc-tag__list cdc-free-course-card__detail-tags" track-click=""><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10165" target="_blank">c 语言</a></div><div class="cdc-tag" track-click="" track-exposure=""><a class="cdc-tag__inner" href="https://cloud.tencent.com/developer/tag/10169" target="_blank">python</a></div></div></div></div></div></div></div></div></div></div></div><div class="cdc-widget-global"><div class="cdc-widget-global__btn announcement"></div><div class="cdc-widget-global__btn code"><div class="cdc-widget-global__btn-tag">领券</div></div><div class="cdc-widget-global__btn top" style="visibility: hidden;"></div></div><div class="cdc-footer"><div class="cdc-footer__inner"><div class="cdc-footer__main"><div class="cdc-footer__website"><ul class="cdc-footer__website-group"><li class="cdc-footer__website-column"><div class="cdc-footer__website-box"><h3 class="cdc-footer__website-title">社区</h3><ul class="cdc-footer__website-list"><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/column">专栏文章</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/inventory">阅读清单</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/ask">互动问答</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/salon">技术沙龙</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/video">技术视频</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/teams">团队主页</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/timl">腾讯云TI平台</a></li></ul></div></li><li class="cdc-footer__website-column"><div class="cdc-footer__website-box"><h3 class="cdc-footer__website-title">活动</h3><ul class="cdc-footer__website-list"><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/support-plan">自媒体同步曝光计划</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/support-plan-invitation">邀请作者入驻</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/article/1535830">自荐上首页</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/competition">技术竞赛</a></li></ul></div></li><li class="cdc-footer__website-column"><div class="cdc-footer__website-box"><h3 class="cdc-footer__website-title">资源</h3><ul class="cdc-footer__website-list"><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/specials">技术周刊</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/tags">社区标签</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/developer/devdocs">开发者手册</a></li><li class="cdc-footer__website-item"><a href="https://cloud.tencent.com/lab?from=20064&amp;from_column=20064">开发者实验室</a></li></ul></div></li><li class="cdc-footer__website-column"><div class="cdc-footer__website-box"><h3 class="cdc-footer__website-title">关于</h3><ul class="cdc-footer__website-list"><li class="cdc-footer__website-item"><a rel="nofollow" href="https://cloud.tencent.com/developer/article/1006434">社区规范</a></li><li class="cdc-footer__website-item"><a rel="nofollow" href="https://cloud.tencent.com/developer/article/1006435">免责声明</a></li><li class="cdc-footer__website-item"><a rel="nofollow" href="mailto:cloudcommunity@tencent.com">联系我们</a></li><li class="cdc-footer__website-item"><a rel="nofollow" href="https://cloud.tencent.com/developer/friendlink">友情链接</a></li></ul></div></li></ul></div><div class="cdc-footer__qr"><h3 class="cdc-footer__qr-title">腾讯云开发者</h3><div class="cdc-footer__qr-object"><img src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/a8907230cd5be483497c7e90b061b861.png" class="cdc-footer__qr-image" alt="扫码关注腾讯云开发者"></div><div class="cdc-footer__qr-infos"><p class="cdc-footer__qr-info"><span class="cdc-footer__qr-text">扫码关注腾讯云开发者</span></p><p class="cdc-footer__qr-info"><span class="cdc-footer__qr-text">领取腾讯云代金券</span></p></div></div></div><div class="cdc-footer__recommend"><div class="cdc-footer__recommend-rows"><div class="cdc-footer__recommend-cell"><h3 class="cdc-footer__recommend-title">热门产品</h3><div class="cdc-footer__recommend-wrap"><ul class="cdc-footer__recommend-list"><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://dnspod.cloud.tencent.com/?from=20064&amp;from_column=20064">域名注册</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cvm?from=20064&amp;from_column=20064">云服务器</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/tbaas?from=20064&amp;from_column=20064">区块链服务</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/mq?from=20064&amp;from_column=20064">消息队列</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/dsa?from=20064&amp;from_column=20064">网络加速</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/tencentdb-catalog?from=20064&amp;from_column=20064">云数据库</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cns?from=20064&amp;from_column=20064">域名解析</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cos?from=20064&amp;from_column=20064">云存储</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/css?from=20064&amp;from_column=20064">视频直播</a></li></ul></div></div><div class="cdc-footer__recommend-cell"><h3 class="cdc-footer__recommend-title">热门推荐</h3><div class="cdc-footer__recommend-wrap"><ul class="cdc-footer__recommend-list"><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/facerecognition?from=20064&amp;from_column=20064">人脸识别</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/tm?from=20064&amp;from_column=20064">腾讯会议</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/act/pro/enterprise2019?from=20064&amp;from_column=20064">企业云</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cdn-scd?from=20064&amp;from_column=20064">CDN加速</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/trtc?from=20064&amp;from_column=20064">视频通话</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/tiia?from=20064&amp;from_column=20064">图像分析</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cdb?from=20064&amp;from_column=20064">MySQL 数据库</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/symantecssl?from=20064&amp;from_column=20064">SSL 证书</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/asr?from=20064&amp;from_column=20064">语音识别</a></li></ul></div></div><div class="cdc-footer__recommend-cell"><h3 class="cdc-footer__recommend-title">更多推荐</h3><div class="cdc-footer__recommend-wrap"><ul class="cdc-footer__recommend-list"><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/solution/data_protection?from=20064&amp;from_column=20064">数据安全</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/clb?from=20064&amp;from_column=20064">负载均衡</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/sms?from=20064&amp;from_column=20064">短信</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/ocr?from=20064&amp;from_column=20064">文字识别</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/vod?from=20064&amp;from_column=20064">云点播</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://tm.cloud.tencent.com/?from=20064&amp;from_column=20064">商标注册</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/solution/la?from=20064&amp;from_column=20064">小程序开发</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cat?from=20064&amp;from_column=20064">网站监控</a></li><li class="cdc-footer__recommend-item"><a class="com-2-footer-recommend-link" href="https://cloud.tencent.com/product/cdm?from=20064&amp;from_column=20064">数据迁移</a></li></ul></div></div></div></div><div class="cdc-footer__copyright"><div class="cdc-footer__copyright-text"><p>Copyright © 2013 - 2024 Tencent Cloud. All Rights Reserved. 腾讯云 版权所有&nbsp;</p><p>深圳市腾讯计算机系统有限公司 ICP备案/许可证号：<a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">粤B2-20090059&nbsp;</a><a href="https://www.beian.gov.cn/portal/index.do" target="_blank">深公网安备号 44030502008569</a></p><p>腾讯云计算（北京）有限责任公司 京ICP证150476号 | &nbsp;<a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">京ICP备11018762号</a> | <a href="https://www.beian.gov.cn/portal/index.do" target="_blank">京公网安备号11010802020287</a></p></div></div></div></div><div style="display: none;"><a href="https://cloud.tencent.com/developer/ask/archives.html">问题归档</a><a href="https://cloud.tencent.com/developer/column/archives.html">专栏文章</a><a href="https://cloud.tencent.com/developer/news/archives.html">快讯文章归档</a><a href="https://cloud.tencent.com/developer/information/all.html">关键词归档</a><a href="https://cloud.tencent.com/developer/devdocs/archives.html">开发者手册归档</a><a href="https://cloud.tencent.com/developer/devdocs/sections_p1.html">开发者手册 Section 归档</a></div><div class="cdc-m-footer"><div class="cdc-m-footer__inner"><div class="cdc-m-footer__copyright"><p>Copyright © 2013 - 2024 Tencent Cloud.</p><p>All Rights Reserved. 腾讯云 版权所有</p></div></div></div><div class="cdc-operate-footer is-hidden"><div class="cdc-operate-footer__inner"><div class="cdc-operate-footer__toggle is-logout"><div class="cdc-operate-footer__toggle-text"><span>登录 </span>后参与评论</div></div><div class="cdc-operate-footer__operations"><div class="cdc-operate-footer__operate"><i class="cdc-operate-footer__operate-icon comment"></i></div><div class="cdc-operate-footer__operate like"><i class="cdc-operate-footer__operate-icon like"></i><span class="cdc-operate-footer__operate-text">3</span></div><div class="cdc-operate-footer__operate"><i class="cdc-operate-footer__operate-icon book"></i></div><div class="cdc-operate-footer__operate"><i class="cdc-operate-footer__operate-icon menu"></i></div><div class="cdc-operate-footer__operate"><i class="cdc-operate-footer__operate-icon more"></i></div></div></div></div><div class="cdc-suspend-pill"><div class="cdc-suspend-pill__inner"><button class="cdc-icon-btn cdc-suspend-pill__item like cdc-icon-btn--text" qct-area="点赞文章" qct-click=""><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M4 22C3.73736 22 3.47728 21.9483 3.23463 21.8478C2.99198 21.7472 2.7715 21.5999 2.58579 21.4142C2.40007 21.2285 2.25275 21.008 2.15224 20.7654C2.05173 20.5227 2 20.2626 2 20V12C2 11.7374 2.05173 11.4773 2.15224 11.2346C2.25275 10.992 2.40007 10.7715 2.58579 10.5858C2.7715 10.4001 2.99198 10.2527 3.23463 10.1522C3.47728 10.0517 3.73736 10 4 10H6L9 2H10C11.0609 2 12.0783 2.42143 12.8284 3.17157C13.5786 3.92172 14 4.93913 14 6V10H19.438C19.7419 10 20.0418 10.0693 20.3149 10.2026C20.588 10.3359 20.8272 10.5297 21.0142 10.7693C21.2012 11.0088 21.3312 11.2878 21.3942 11.5851C21.4572 11.8824 21.4517 12.1902 21.378 12.485L19.758 18.97C19.5416 19.8357 19.042 20.6042 18.3386 21.1532C17.6351 21.7022 16.7683 22.0003 15.876 22H4ZM6 12H4V20H6V12ZM10.386 4L8 10.363V20H15.877C16.323 19.9999 16.7562 19.8508 17.1077 19.5763C17.4592 19.3018 17.7088 18.9177 17.817 18.485L19.438 12H12V5.614C12 4.772 11.355 4.081 10.533 4.007L10.386 4Z"></path></svg></span></span><span class="cdc-suspend-pill__item-number">3</span></button><button class="cdc-icon-btn cdc-suspend-pill__item like cdc-icon-btn--text"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentcolor"><path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 11.25C17.5 11.9404 16.9404 12.5 16.25 12.5C15.5596 12.5 15 11.9404 15 11.25C15 10.5596 15.5596 10 16.25 10C16.9404 10 17.5 10.5596 17.5 11.25Z M12.25 12.5C12.9404 12.5 13.5 11.9404 13.5 11.25C13.5 10.5596 12.9404 10 12.25 10C11.5596 10 11 10.5596 11 11.25C11 11.9404 11.5596 12.5 12.25 12.5Z M8.25 12.5C8.94036 12.5 9.5 11.9404 9.5 11.25C9.5 10.5596 8.94036 10 8.25 10C7.55964 10 7 10.5596 7 11.25C7 11.9404 7.55964 12.5 8.25 12.5Z M5 3C3.34315 3 2 4.34315 2 6V16C2 17.6569 3.34315 19 5 19H8.34311L10.5858 21.2426C11.3668 22.0237 12.6331 22.0237 13.4142 21.2426L15.6568 19H19C20.6569 19 22 17.6569 22 16V6C22 4.34315 20.6569 3 19 3H5ZM4 6C4 5.44772 4.44772 5 5 5H19C19.5523 5 20 5.44772 20 6V16C20 16.5523 19.5523 17 19 17H14.8284L12 19.8284L9.17154 17H5C4.44772 17 4 16.5523 4 16V6Z"></path></svg></span></span><span class="cdc-suspend-pill__item-number">0</span></button><button class="cdc-icon-btn cdc-suspend-pill__item collect cdc-icon-btn--text" qct-area="收藏文章" qct-click=""><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.2057 3.11487C10.9393 1.62838 13.059 1.62838 13.7927 3.11487L15.9724 7.53141L20.8463 8.23963C22.4867 8.478 23.1418 10.4939 21.9547 11.651L18.4279 15.0888L19.2605 19.9431C19.5407 21.5769 17.8258 22.8228 16.3586 22.0514L11.9992 19.7596L7.63981 22.0514C6.17255 22.8228 4.45769 21.5769 4.73791 19.9431L5.57048 15.0888L2.04366 11.651C0.856629 10.4939 1.51165 8.478 3.15209 8.23963L8.02603 7.53141L10.2057 3.11487ZM11.9992 4L9.8195 8.41654C9.52818 9.00683 8.96504 9.41597 8.31363 9.51062L3.43969 10.2188L6.9665 13.6566C7.43787 14.1161 7.65297 14.7781 7.5417 15.4269L6.70913 20.2812L11.0685 17.9893C11.6512 17.683 12.3472 17.683 12.9299 17.9893L17.2893 20.2812L16.4567 15.4269C16.3454 14.7781 16.5605 14.1161 17.0319 13.6566L20.5587 10.2188L15.6848 9.51062C15.0333 9.41597 14.4702 9.00683 14.1789 8.41654L11.9992 4Z"></path></svg></span></span><span class="cdc-suspend-pill__item-number">0</span></button><button class="cdc-icon-btn cdc-suspend-pill__item cdc-icon-btn--text"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M13.0001 4V6H17.5859L10.1787 13.4072L11.6043 14.81L19.0001 7.41424V12H21.0001V4H13.0001Z"></path><path d="M3 12.9996C3 8.71646 5.99202 5.13211 10 4.22266V6.28952C7.10851 7.15007 5 9.82862 5 12.9996C5 16.8656 8.13401 19.9996 12 19.9996C15.1709 19.9996 17.8494 17.8912 18.71 14.9999H20.7769C19.8674 19.0077 16.2831 21.9996 12 21.9996C7.02944 21.9996 3 17.9702 3 12.9996Z"></path></svg></span></span></button><button class="cdc-icon-btn cdc-suspend-pill__item cdc-icon-btn--text"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2 6C2 4.34315 3.34315 3 5 3H17C18.6569 3 20 4.34315 20 6V11H18V6C18 5.44772 17.5523 5 17 5H5C4.44772 5 4 5.44772 4 6V18C4 18.5523 4.44772 19 5 19H12V21H5C3.34315 21 2 19.6569 2 18V6ZM6 8H12V10H6V8ZM6 12H15V14H6V12ZM22 16H19V13H17V16H14V18H17V21H19V18H22V16Z"></path></svg></span></span></button><div class="cdc-suspend-pill__line"></div><button class="cdc-icon-btn cdc-suspend-pill__item cdc-icon-btn--text"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M16.5047 6H13V4H20V10.876H18V7.33313L14.4571 10.876L13.0429 9.46182L16.5047 6Z"></path><path d="M11 6.00006H7.4953L10.9571 9.46189L9.54291 10.8761L6 7.33319V10.8761H4V4.00006H11V6.00006Z"></path><path d="M7.4953 18.8761H11V20.8761H4V14.0001H6V17.543L9.54291 14.0001L10.9571 15.4143L7.4953 18.8761Z"></path><path d="M16.5047 18.8761H13V20.8761H20V14.0001H18V17.543L14.4571 14.0001L13.0429 15.4143L16.5047 18.8761Z"></path></svg></span></span></button><button class="cdc-icon-btn cdc-suspend-pill__item recommend cdc-icon-btn--text" track-click="{&quot;areaId&quot;:106019,&quot;recPolicyId&quot;:1002,&quot;elementId&quot;:2}" track-exposure="{&quot;areaId&quot;:106019,&quot;recPolicyId&quot;:1002,&quot;elementId&quot;:2}"><span class="cdc-svg-icon-con"><span class="cdc-svg-icon" style="width: 24px; height: 24px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M5 8H10V10H5V8Z"></path><path d="M10 12H5V14H10V12Z"></path><path d="M14 8H19V10H14V8Z"></path><path d="M19 12H14V14H19V12Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M11 20.608L9.57047 20.1996C8.83303 19.9889 8.05701 19.9506 7.30243 20.0878L4.35777 20.6232C3.13009 20.8464 2 19.9033 2 18.6555V5.2669C2 4.2325 2.78877 3.36877 3.81893 3.27512L6.52892 3.02875C7.95704 2.89892 9.39058 3.21084 10.6356 3.9223L12 4.70194L13.3644 3.9223C14.6094 3.21084 16.043 2.89892 17.4711 3.02875L20.1811 3.27512C21.2112 3.36877 22 4.2325 22 5.2669V18.6555C22 19.9033 20.8699 20.8464 19.6422 20.6232L16.6976 20.0878C15.943 19.9506 15.167 19.9889 14.4295 20.1996L13 20.608L12.5 20.8535L12 20.8937L11.5 20.8535L11 20.608ZM6.70999 5.02054C7.73007 4.9278 8.75403 5.1506 9.64336 5.65879L11 6.43401V18.528L10.1199 18.2765C9.0875 17.9815 8.00107 17.928 6.94466 18.1201L4 18.6555V5.2669L6.70999 5.02054ZM13 18.528L13.8801 18.2765C14.9125 17.9815 15.9989 17.928 17.0553 18.1201L20 18.6555V5.2669L17.29 5.02054C16.2699 4.9278 15.246 5.1506 14.3566 5.65879L13 6.43401V18.528Z"></path></svg></span></span><span class="cdc-suspend-pill__item-text">推荐</span></button></div></div></div></div></div><script>
          if (!String.prototype.replaceAll) {
            String.prototype.replaceAll = function (str, newStr) {
              // If a regex pattern
              if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {
                return this.replace(str, newStr);
              }
        
              // If a string
              return this.replace(new RegExp(str, 'g'), newStr);
            };
          }
          </script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/jquery.min.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/api.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/react.16.8.6.min.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/TXLivePlayer-1.2.0.min.js.下载" defer=""></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/hls.min.0.13.2m.js.下载"></script><script src="./深入理解C11_C++11内存模型-腾讯云开发者社区-腾讯云_files/tcplayer.v4.1.min.js.下载"></script><script id="__NEXT_DATA__" type="application/json">{"props":{"isMobile":false,"isSupportWebp":true,"reqId":"7YMh8smKDCRebd_SZq1Dd","query":{"articleId":"1638672"},"platform":"other","env":"production","__N_SSP":true,"pageProps":{"fallback":{"#url:\"/api/article/detail\",params:#articleId:1638672,,":{"articleData":{"articleId":1638672,"codeLineNum":231,"readingTime":1262,"wordsNum":5784},"articleInfo":{"articleId":1638672,"channel":4,"commentNum":0,"content":{"entityMap":{"0":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"imageUrl":"https://ask.qcloudimg.com/http-save/yehe-5465588/93t5m0g6j5.png","imageAlt":"","blockWidth":548,"blockHeight":322}},"1":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"imageUrl":"https://ask.qcloudimg.com/http-save/yehe-5465588/ti94sky0rg.png","imageAlt":"","blockWidth":1080,"blockHeight":439}}},"blocks":[{"key":"apkol","text":"现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这是多处理器架构下并发编程里必须掌握的一个基础概念。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"21dld","text":"1. 什么是内存模型？\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"620nl","text":"到底什么是内存模型呢？看到有两种不同的观点：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d0vfb","text":"A：内存模型是从来描述编程语言在支持多线程编程中对共享内存访问的顺序。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2d7pv","text":"B：内存模型的本质是指在单线程情况下CPU指令在多大程度上发生指令重排(reorder)[1]。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7osdv","text":"实际上A，B两种说法都是正确的，只不过是在尝试从不同的角度去说明memory model的概念。个人认为，内存模型表达为“内存顺序模型”可能更加贴切一点。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ciej7","text":"一个良好的memory model定义包含3个方面：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3vvnt","text":"Atomic Operations","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8634s","text":"Partial order of operations","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4ena7","text":"Visable effects of operations","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"66bet","text":"这里要强调的是：我们这里所说的内存模型和CPU的体系结构、编译器实现和编程语言规范3个层面都有关系。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3risv","text":"首先，不同的CPU体系结构内存顺序模型是不一样的，但大致分为两种：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"drsu1","text":"ArchitectureMemory Modelx86_64Total Store OrderSparcTotal Store OrderARMv8Weakly OrderedPowerPCWeakly OrderedMIPSWeakly Ordered\n\n","type":"table","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"aligns":[{"key":"29sna","align":"left"},{"key":"r39k","align":"left"}],"rows":[{"key":"bt40l","cells":[{"key":"97p9g","raw":{"blocks":[{"key":"13qvu","type":"unstyled","text":"Architecture","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"k4tr","raw":{"blocks":[{"key":"c97l3","type":"unstyled","text":"Memory Model","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"baua2","cells":[{"key":"68gk2","raw":{"blocks":[{"key":"9km88","type":"unstyled","text":"x86_64","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"dilka","raw":{"blocks":[{"key":"e64tn","type":"unstyled","text":"Total Store Order","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"24dlo","cells":[{"key":"eq24e","raw":{"blocks":[{"key":"9qgea","type":"unstyled","text":"Sparc","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"23do0","raw":{"blocks":[{"key":"944ie","type":"unstyled","text":"Total Store Order","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"ev0hq","cells":[{"key":"djd1v","raw":{"blocks":[{"key":"7f9dm","type":"unstyled","text":"ARMv8","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"e8162","raw":{"blocks":[{"key":"9rvhe","type":"unstyled","text":"Weakly Ordered","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"3ac6e","cells":[{"key":"4bnsr","raw":{"blocks":[{"key":"s476","type":"unstyled","text":"PowerPC","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"4r0og","raw":{"blocks":[{"key":"fr6gc","type":"unstyled","text":"Weakly Ordered","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"eiddf","cells":[{"key":"897t7","raw":{"blocks":[{"key":"1ja6g","type":"unstyled","text":"MIPS","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"ac5om","raw":{"blocks":[{"key":"ffuj0","type":"unstyled","text":"Weakly Ordered","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"91hkf","cells":[{"key":"f12ef","raw":{"blocks":[{"key":"i3d6","type":"unstyled","text":"","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"4ul9b","raw":{"blocks":[{"key":"bsu03","type":"unstyled","text":"","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]}]}},{"key":"buvli","text":"x86_64和Sparc是强顺序模型（Total Store Order），这是一种接近程序顺序的顺序模型。所谓Total，就是说，内存（在写操作上）是有一个全局的顺序的（所有人看到的一样的顺序）， 就好像在内存上的每个Store动作必须有一个排队，一个弄完才轮到另一个，这个顺序和你的程序顺序直接相关。所有的行为组合只会是所有CPU内存程序顺序的交织，不会发生和程序顺序不一致的地方[4]。TSO模型有利于多线程程序的编写，对程序员更加友好，但对芯片实现者不友好。CPU为了TSO的承诺，会牺牲一些并发上的执行效率。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dqvip","text":"弱内存模型（简称WMO，Weak Memory Ordering），是把是否要求强制顺序这个要求直接交给程序员的方法。换句话说，CPU不去保证这个顺序模型（除非他们在一个CPU上就有依赖）， 程序员要主动插入内存屏障指令来强化这个“可见性”[4]。ARMv8，PowerPC和MIPS等体系结构都是弱内存模型。每种弱内存模型的体系架构都有自己的内存屏障指令，语义也不完全相同。弱内存模型下，硬件实现起来相对简单，处理器执行的效率也高， 只要没有遇到显式的屏障指令，CPU可以对局部指令进行reorder以提高执行效率。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c55fb","text":"对于多线程程序开发来说，对并发的数据访问我们一般到做同步操作， 可以使用mutex，semaphore，conditional等重量级方案对共享数据进行保护。但为了实现更高的并发，需要使用内存共享变量做通信（Message Passing）， 这就对程序员的要求很高了，程序员必须时时刻刻必须很清楚自己在做什么， 否则写出来的程序的执行行为会让人很是迷惑！值得一提的是，并发虽好，如果能够简单粗暴实现，就不要搞太多投机取巧！要实现lock-free无锁编程真的有点难。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"13ack","text":"其次，不同的编程语言对内存模型都有自己的规范，例如：C/C++和Java等不同的编程语言都有定义内存模型相关规范。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"21l8d","text":"2011年发布的C11/C++11 ISO Standard为我们带来了memory order的支持， 引用C++11里的一段描述：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8sto1","text":"The memory model means that C++ code now has a standardized\nlibrary to call regardless of who made the compiler and on\nwhat platform it's running. There's a standard way to control\nhow different threads talk to the processor's memory.[7]\n","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"anj8q","text":"memory order的问题就是因为指令重排引起的, 指令重排导致 原来的内存可见顺序发生了变化, 在单线程执行起来的时候是没有问题的, 但是放到 多核/多线程执行的时候就出现问题了, 为了效率引入的额外复杂逻辑的的弊端就出现了[8]。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ck1ub","text":"C++11引入memory order的意义在于我们现在有了一个与运行平台无关和编译器无关的标准库， 让我们可以在high level languange层面实现对多处理器对共享内存的交互式控制。我们的多线程终于可以跨平台啦！我们可以借助内存模型写出更好更安全的并发代码。真棒，简直不要太优秀~","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2jebg","text":"?","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"5h6ca","text":"C11/C++11使用memory order来描述memory model， 而用来联系memory order的是atomic变量， atomic操作可以用load()和release()语义来描述。一个简单的atomic变量赋值可描述为：\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3lnn4","text":" atomic_var1.store (atomic_var2.load()); // atomic variables\n     vs\n var1 = var2;                            // regular variables\n","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"afgbd","text":"为了更好地描述内存模型，有4种关系术语需要了解一下。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1rpkn","text":"sequenced-before","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8d9hg","text":"同一个线程之内，语句A的执行顺序在语句B前面，那么就成为A sequenced-before B。它不仅仅表示两个操作之间的先后顺序，还表示了操作结果之间的可见性关系。两个操作A和操作B，如果有A sequenced-before B，除了表示操作A的顺序在B之前，还表示了操作A的结果操作B可见。例如：语句A是sequenced-before语句B的。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3u3ml","text":"r2 = x.load(std::memory_order_relaxed); // A\ny.store(42, std::memory_order_relaxed); // B","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"76k1h","text":"happens-before","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"happens-before"}},{"key":"1sjq8","text":"happens-before关系表示的不同线程之间的操作先后顺序。如果A happens-before B，则A的内存状态将在B操作执行之前就可见。happends-before关系满足传递性、非自反性和非对称性。happens before包含了inter-thread happens before和synchronizes-with两种关系。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1rqga","text":"synchronizes-with","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"et4v9","text":"synchronizes-with关系强调的是变量被修改之后的传播关系（propagate）， 即如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的[9]。另外synchronizes-with可以被认为是跨线程间的happends-before关系。显然，满足synchronizes-with关系的操作一定满足happens-before关系了。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"28nl7","text":"Carries dependency","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ebdve","text":"同一个线程内，表达式A sequenced-before 表达式B，并且表达式B的值是受表达式A的影响的一种关系， 称之为\"Carries dependency\"。这个很好理解，例如：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3i3v3","text":"int *a = \u0026var1;\nint *b = \u0026var2;\nc = *a + *b;\n","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"71brf","text":"了解了上面一些基本概念，下面我们来一起学习一下内存模型吧。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"j5aq","text":"2. C11/C++11内存模型","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bcpid","text":"C/C++11标准中提供了6种memory order，来描述内存模型[6]:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"412a5","text":"enum memory_order {\n    memory_order_relaxed,\n    memory_order_consume,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_acq_rel,\n    memory_order_seq_cst\n};","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"2dg4j","text":"每种memory order的规则可以简要描述为：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"52ma6","text":"枚举值定义规则memory_order_relaxed不对执行顺序做任何保证memory_order_consume本线程中，所有后续的有关本原子类型的操作，必须在本条原子操作完成之后执行memory_order_acquire本线程中，所有后续的读操作必须在本条原子操作完成后执行memory_order_release本线程中，所有之前的写操作完成后才能执行本条原子操作memory_order_acq_rel同时包含memory_order_acquire和memory_order_release标记memory_order_seq_cst全部存取都按顺序执行\n\n","type":"table","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"aligns":[{"key":"dd58a","align":"left"},{"key":"3ttek","align":"left"}],"rows":[{"key":"c85sk","cells":[{"key":"1f8nl","raw":{"blocks":[{"key":"7bsjn","type":"unstyled","text":"枚举值","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"1rbb2","raw":{"blocks":[{"key":"dq465","type":"unstyled","text":"定义规则","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"2do8l","cells":[{"key":"8aetc","raw":{"blocks":[{"key":"7qf9h","type":"unstyled","text":"memory_order_relaxed","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"b8o28","raw":{"blocks":[{"key":"69od","type":"unstyled","text":"不对执行顺序做任何保证","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"2qbvd","cells":[{"key":"1p5a2","raw":{"blocks":[{"key":"8go3r","type":"unstyled","text":"memory_order_consume","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"dgdqm","raw":{"blocks":[{"key":"a42nr","type":"unstyled","text":"本线程中，所有后续的有关本原子类型的操作，必须在本条原子操作完成之后执行","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"6qfg6","cells":[{"key":"c9vn0","raw":{"blocks":[{"key":"dtjdo","type":"unstyled","text":"memory_order_acquire","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"a15p7","raw":{"blocks":[{"key":"d1qor","type":"unstyled","text":"本线程中，所有后续的读操作必须在本条原子操作完成后执行","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"2c1n6","cells":[{"key":"ae410","raw":{"blocks":[{"key":"3qcvd","type":"unstyled","text":"memory_order_release","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"79ru1","raw":{"blocks":[{"key":"c8sef","type":"unstyled","text":"本线程中，所有之前的写操作完成后才能执行本条原子操作","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"2in27","cells":[{"key":"2jccd","raw":{"blocks":[{"key":"2dgt8","type":"unstyled","text":"memory_order_acq_rel","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"d4u2r","raw":{"blocks":[{"key":"c04ju","type":"unstyled","text":"同时包含memory_order_acquire和memory_order_release标记","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"4j86o","cells":[{"key":"7g0vv","raw":{"blocks":[{"key":"a90uf","type":"unstyled","text":"memory_order_seq_cst","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"dgtr2","raw":{"blocks":[{"key":"1h778","type":"unstyled","text":"全部存取都按顺序执行","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]},{"key":"cvucs","cells":[{"key":"cg3nk","raw":{"blocks":[{"key":"7lmui","type":"unstyled","text":"","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}},{"key":"6hp9r","raw":{"blocks":[{"key":"6ibp8","type":"unstyled","text":"","inlineStyleRanges":[],"entityRanges":[]}],"entityMap":{}}}]}]}},{"key":"j368","text":"?","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":1}],"data":{}},{"key":"4m3a8","text":" 下面我们来举例一一说明，扒开内存模型的神秘面纱。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cb5r5","text":"2.1 memory order releaxed","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"98evi","text":"relaxed表示一种最为宽松的内存操作约定，Relaxed ordering 仅仅保证load()和store()是原子操作， 除此之外，不提供任何跨线程的同步[5]。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"a5tlf","text":"                   std::atomic\u003cint\u003e x = 0;     // global variable\n                   std::atomic\u003cint\u003e y = 0;     // global variable\n\t\t  \nThread-1:                                  Thread-2:\nr1 = y.load(memory_order_relaxed); // A    r2 = x.load(memory_order_relaxed); // C\nx.store(r1, memory_order_relaxed); // B    y.store(42, memory_order_relaxed); // D\n","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"5rimk","text":"上面的多线程模型执行的时候，可能出现r2 == r1 == 42。要理解这一点并不难，因为CPU在执行的时候允许局部指令重排reorder，D可能在C前执行。如果程序的执行顺序是 D -\u003e A -\u003e B -\u003e C，那么就会出现r1 == r2 == 42。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cnrvi","text":"如果某个操作只要求是原子操作，除此之外，不需要其它同步的保障，那么就可以使用 relaxed ordering。程序计数器是一种典型的应用场景：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a4asg","text":"#include \u003ccassert\u003e\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n#include \u003cthread\u003e\n#include \u003catomic\u003e\n\nstd::atomic\u003cint\u003e cnt = {0};\nvoid f()\n{\n    for (int n = 0; n \u003c 1000; ++n) {\n        cnt.fetch_add(1, std::memory_order_relaxed);\n    }\n}\nint main()\n{\n    std::vector\u003cstd::thread\u003e v;\n    for (int n = 0; n \u003c 10; ++n) {\n        v.emplace_back(f);\n    }\n    for (auto\u0026 t : v) {\n        t.join();\n    }\n    assert(cnt == 10000);    // never failed\n    return 0;\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"fks4t","text":"cnt是共享的全局变量，多个线程并发地对cnt执行RMW（Read Modify Write）原子操作。这里只保证cnt的原子性，其他有依赖cnt的地方不保证任何的同步。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"},{"offset":20,"length":3,"style":"CODE"},{"offset":57,"length":3,"style":"CODE"},{"offset":70,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"adi2j","text":"2.2 memory order consume","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6771o","text":"consume要搭配release一起使用。很多时候，线程间只想针对有依赖关系的操作进行同步， 除此之外线程中其他操作顺序如何不关心，这时候就适合用consume来完成这个操作。例如：","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"CODE"},{"offset":10,"length":7,"style":"CODE"},{"offset":74,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"d78v8","text":"b = *a;\nc = *b","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"fi8ai","text":"第二行的变量c依赖于第一行的执行结果，因此这两行代码是\"Carries dependency\"关系。显然，由于consume是针对有明确依赖关系的语句来限定其执行顺序的一种内存顺序， 而releaxed不提供任何顺序保证， 所以consume order要比releaxed order要更加地Strong。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":55,"length":7,"style":"CODE"},{"offset":93,"length":8,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"25ee","text":"#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n#include \u003cstring\u003e\n\nstd::atomic\u003cstd::string*\u003e ptr;\nint data;\n\nvoid producer()\n{\n    std::string* p  = new std::string(\"Hello\");\n    data = 42;\n    ptr.store(p, std::memory_order_release);\n}\n\nvoid consumer()\n{\n    std::string* p2;\n    while (!(p2 = ptr.load(std::memory_order_consume)))\n        ;\n    assert(*p2 == \"Hello\");  // never fires: *p2 carries dependency from ptr\n    assert(data == 42);      // may or may not fire: data does not carry dependency from ptr\n}\n\nint main()\n{\n    std::thread t1(producer);\n    std::thread t2(consumer);\n    t1.join();\n    t2.join();\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"2hcil","text":"assert(*p2 == \"Hello\")永远不会失败，但assert(data == 42)可能会。原因是：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6j8iq","text":"p2和ptr直接有依赖关系，但data和ptr没有直接依赖关系，","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3eqd8","text":"尽管线程1中data赋值在ptr.store()之前，线程2看到的data的值还是不确定的。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b7jtr","text":"2.3 memory order acquire","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"2.3-memory-order-acquire"}},{"key":"7i84l","text":"acquire和release也必须放到一起使用。 release和acquire构成了synchronize-with关系，也就是同步关系。在这个关系下：线程A中所有发生在release x之前的值的写操作， 对线程B的acquire x之后的任何操作都可见。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"CODE"},{"offset":8,"length":7,"style":"CODE"},{"offset":26,"length":7,"style":"CODE"},{"offset":34,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"1kht9","text":"#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n#include \u003cstring\u003e\n#include \u003ciostream\u003e\n\nstd::atomic\u003cbool\u003e ready{ false };\nint data = 0;\nstd::atomic\u003cint\u003e var = {0};\n\nvoid sender()\n{\n    data = 42;                                              // A\n    var.store(100, std::memory_order_relaxed);              // B\n    ready.store(true, std::memory_order_release);           // C\n}\nvoid receiver()\n{\n    while (!ready.load(std::memory_order_acquire))          // D\n        ;\n    assert(data == 42);  // never failed                    // E\n    assert(var == 100);  // never failed                    // F\n}\n\nint main()\n{\n    std::thread t1(sender);\n    std::thread t2(receiver);\n    t1.join();\n    t2.join();\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"cktt5","text":"上面的例子中：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fgtjc","text":"sender线程中data = 42是sequence before原子变量ready的","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":9,"length":9,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"7g8bi","text":"sender和receiver在C和D处发生了同步","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eoj96","text":"线程sender中C之前的所有读写对线程receiver都是可见的 显然， release和acquire组合在一起比release和consume组合更加Strong！","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":38,"length":7,"style":"CODE"},{"offset":46,"length":7,"style":"CODE"},{"offset":59,"length":7,"style":"CODE"},{"offset":67,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"b9gtg","text":"2.4 memory order release","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"2.4-memory-order-release"}},{"key":"52qr6","text":"release order一般不单独使用，它和acquire和consume组成2种独立的内存顺序搭配。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":23,"length":7,"style":"CODE"},{"offset":31,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"esa8u","text":"这里就不用展开啰里啰嗦了。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6j6q5","text":"2.5 memory order acq_rel","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"2.5-memory-order-acq_rel"}},{"key":"83kbm","text":"acq_rel是acquire和release的叠加。中文不知道该咋描述好：","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"b1fdd","text":"A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.\n","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"5q785","text":"大致意思是：memory_order_acq_rel适用于read-modify-write operation， 对于采用此内存序的read-modify-write operation，我们可以称为acq_rel operation， 既属于acquire operation 也是release operation. 设有一个原子变量M上的acq_rel operation：自然的，该acq_rel operation之前的内存读写都不能重排到该acq_rel operation之后， 该acq_rel operation之后的内存读写都不能重排到该acq_rel operation之前. 其他线程中所有对M的release operation及其之前的写入都对当前线程从该acq_rel operation开始的操作可见， 并且截止到该acq_rel operation的所有内存写入都对另外线程对M的acquire operation以及之后的内存操作可见[13]。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1qutl","text":"这里是一个例子，关于为什么要有acq_rel可以参考一下：","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":15,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"b2bbj","text":"#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n#include \u003cvector\u003e\n \nstd::vector\u003cint\u003e data;\nstd::atomic\u003cint\u003e flag = {0};\n \nvoid thread_1()\n{\n    data.push_back(42);\n    flag.store(1, std::memory_order_release);\n}\n \nvoid thread_2()\n{\n    int expected=1;\n    while (!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel)) {\n        expected = 1;\n    }\n}\n \nvoid thread_3()\n{\n    while (flag.load(std::memory_order_acquire) \u003c 2)\n        ;\n    assert(data.at(0) == 42); // will never fire\n}\n \nint main()\n{\n    std::thread a(thread_1);\n    std::thread b(thread_2);\n    std::thread c(thread_3);\n    a.join(); b.join(); c.join();\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"i2nn","text":"2.6 memory order seq_cst","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"2.6-memory-order-seq_cst"}},{"key":"b79hc","text":"seq_cst表示顺序一致性内存模型，在这个模型约束下不仅同一个线程内的执行结果是和程序顺序一致的， 每个线程间互相看到的执行结果和程序顺序也保持顺序一致。显然，seq_cst的约束是最强的，这意味着要牺牲性能为代价。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"CODE"},{"offset":81,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"7krup","text":"        atomic int x (0);               atomic int y (0);\n    x. store (1, seq cst );     ||      y. store (1, seq cst );\n    int r1 = y.load( seq cst ); ||      int r2 = x.load( seq cst );\n                assert (r1 == 1 || r2 == 1);\n","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"fiskq","text":"下面是一个seq_cst的实例：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5q8sh","text":"#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n \nstd::atomic\u003cbool\u003e x = {false};\nstd::atomic\u003cbool\u003e y = {false};\nstd::atomic\u003cint\u003e z = {0};\n \nvoid write_x()\n{\n    x.store(true, std::memory_order_seq_cst);\n}\n \nvoid write_y()\n{\n    y.store(true, std::memory_order_seq_cst);\n}\n \nvoid read_x_then_y()\n{\n    while (!x.load(std::memory_order_seq_cst))\n        ;\n    if (y.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\n \nvoid read_y_then_x()\n{\n    while (!y.load(std::memory_order_seq_cst))\n        ;\n    if (x.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\n \nint main()\n{\n    std::thread a(write_x);\n    std::thread b(write_y);\n    std::thread c(read_x_then_y);\n    std::thread d(read_y_then_x);\n    a.join(); b.join(); c.join(); d.join();\n    assert(z.load() != 0);  // will never happen\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"67vcb","text":"2.7 Relationship with volatile","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"2.7-Relationship-with-volatile"}},{"key":"7v714","text":"人的一生总是充满了疑惑。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4r1mu","text":"可能你会思考？volatile关键字能够防止指令被编译器优化，那它能提供线程间(inter-thread)同步语义吗？答案是：不能！！！","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8up99","text":"尽管volatile能够防止单个线程内对volatile变量进行reorder，但多个线程同时访问同一个volatile变量，线程间是完全不提供同步保证。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9dsd4","text":"而且，volatile不提供原子性！","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5kd42","text":"并发的读写volatile变量是会产生数据竞争的，同时non volatile操作可以在volatile操作附近自由地reorder。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6p21n","text":"看一个例子，执行下面的并发程序，不出意外的话，你不会得到一个为0的结果。","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dj1s","text":"#include \u003cthread\u003e\n#include \u003ciostream\u003e\n\nvolatile int count = 0;\n\nvoid increase() {\n    for (int i = 0; i \u003c 1000000; i++) {\n        count++;\n    }\n}\n\nvoid decrease() {\n    for (int i = 0; i \u003c 1000000; i++) {\n        count--;\n    }\n}\n\nint main() {\n    std::thread t1(increase);\n    std::thread t2(decrease);\n    t1.join();\n    t2.join();\n    std::cout \u003c\u003c count \u003c\u003c std::endl;\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"syntax":"javascript"}},{"key":"2n5us","text":"3. Reference","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{"text":"3.-Reference"}},{"key":"7ql3c","text":"The C/C++ Memory Model: Overview and Formalization","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a8gbp","text":"知乎专栏：如何理解C++的6种memory order","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4pp6n","text":"理解 C++ 的 Memory Order","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2ptf","text":"理解弱内存顺序模型","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5dahu","text":"当我们在谈论 memory order 的时候，我们在谈论什么","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c4trd","text":"https://en.cppreference.com/w/cpp/atomic/memory_order","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ge0j","text":"Youtube: Atomic’s memory orders, what for? - Frank Birbacher [ACCU 2017]","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bdna8","text":"C++11中的内存模型下篇 - C++11支持的几种内存模型","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5u7oj","text":"memory ordering, Gavin's blog","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"elsvq","text":"c++11 内存模型解读","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f8i2c","text":"memory barriers in c, MariaDB FOUNDATION, pdf","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ahhv3","text":"C++ memory order循序渐进","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"75vfo","text":"Memory Models for C/C++ Programers","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dvo36","text":"Memory Consistency Models: A Tutorial","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"createTime":1591255179,"ext":{"closeTextLink":0,"comment_ban":0,"description":"","focusRead":0},"favNum":0,"isOriginal":0,"likeNum":3,"pic":"","plain":"现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这是多处理器架构下并发编程里必须掌握的一个基础概念。\n1. 什么是内存模型？\n\n到底什么是内存模型呢？看到有两种不同的观点：\nA：内存模型是从来描述编程语言在支持多线程编程中对共享内存访问的顺序。\nB：内存模型的本质是指在单线程情况下CPU指令在多大程度上发生指令重排(reorder)[1]。\n实际上A，B两种说法都是正确的，只不过是在尝试从不同的角度去说明memory model的概念。个人认为，内存模型表达为“内存顺序模型”可能更加贴切一点。\n一个良好的memory model定义包含3个方面：\nAtomic Operations\nPartial order of operations\nVisable effects of operations\n这里要强调的是：我们这里所说的内存模型和CPU的体系结构、编译器实现和编程语言规范3个层面都有关系。\n首先，不同的CPU体系结构内存顺序模型是不一样的，但大致分为两种：\nArchitecture\tMemory Model\nx86_64\tTotal Store Order\nSparc\tTotal Store Order\nARMv8\tWeakly Ordered\nPowerPC\tWeakly Ordered\nMIPS\tWeakly Ordered\n\t\n\nx86_64和Sparc是强顺序模型（Total Store Order），这是一种接近程序顺序的顺序模型。所谓Total，就是说，内存（在写操作上）是有一个全局的顺序的（所有人看到的一样的顺序）， 就好像在内存上的每个Store动作必须有一个排队，一个弄完才轮到另一个，这个顺序和你的程序顺序直接相关。所有的行为组合只会是所有CPU内存程序顺序的交织，不会发生和程序顺序不一致的地方[4]。TSO模型有利于多线程程序的编写，对程序员更加友好，但对芯片实现者不友好。CPU为了TSO的承诺，会牺牲一些并发上的执行效率。\n弱内存模型（简称WMO，Weak Memory Ordering），是把是否要求强制顺序这个要求直接交给程序员的方法。换句话说，CPU不去保证这个顺序模型（除非他们在一个CPU上就有依赖）， 程序员要主动插入内存屏障指令来强化这个“可见性”[4]。ARMv8，PowerPC和MIPS等体系结构都是弱内存模型。每种弱内存模型的体系架构都有自己的内存屏障指令，语义也不完全相同。弱内存模型下，硬件实现起来相对简单，处理器执行的效率也高， 只要没有遇到显式的屏障指令，CPU可以对局部指令进行reorder以提高执行效率。\n对于多线程程序开发来说，对并发的数据访问我们一般到做同步操作， 可以使用mutex，semaphore，conditional等重量级方案对共享数据进行保护。但为了实现更高的并发，需要使用内存共享变量做通信（Message Passing）， 这就对程序员的要求很高了，程序员必须时时刻刻必须很清楚自己在做什么， 否则写出来的程序的执行行为会让人很是迷惑！值得一提的是，并发虽好，如果能够简单粗暴实现，就不要搞太多投机取巧！要实现lock-free无锁编程真的有点难。\n其次，不同的编程语言对内存模型都有自己的规范，例如：C/C++和Java等不同的编程语言都有定义内存模型相关规范。\n2011年发布的C11/C++11 ISO Standard为我们带来了memory order的支持， 引用C++11里的一段描述：\nThe memory model means that C++ code now has a standardized\nlibrary to call regardless of who made the compiler and on\nwhat platform it's running. There's a standard way to control\nhow different threads talk to the processor's memory.[7]\n\nmemory order的问题就是因为指令重排引起的, 指令重排导致 原来的内存可见顺序发生了变化, 在单线程执行起来的时候是没有问题的, 但是放到 多核/多线程执行的时候就出现问题了, 为了效率引入的额外复杂逻辑的的弊端就出现了[8]。\nC++11引入memory order的意义在于我们现在有了一个与运行平台无关和编译器无关的标准库， 让我们可以在high level languange层面实现对多处理器对共享内存的交互式控制。我们的多线程终于可以跨平台啦！我们可以借助内存模型写出更好更安全的并发代码。真棒，简直不要太优秀~\n?\nC11/C++11使用memory order来描述memory model， 而用来联系memory order的是atomic变量， atomic操作可以用load()和release()语义来描述。一个简单的atomic变量赋值可描述为：\n\n atomic_var1.store (atomic_var2.load()); // atomic variables\n     vs\n var1 = var2;                            // regular variables\n\n为了更好地描述内存模型，有4种关系术语需要了解一下。\nsequenced-before\n同一个线程之内，语句A的执行顺序在语句B前面，那么就成为A sequenced-before B。它不仅仅表示两个操作之间的先后顺序，还表示了操作结果之间的可见性关系。两个操作A和操作B，如果有A sequenced-before B，除了表示操作A的顺序在B之前，还表示了操作A的结果操作B可见。例如：语句A是sequenced-before语句B的。\nr2 = x.load(std::memory_order_relaxed); // A\ny.store(42, std::memory_order_relaxed); // B\nhappens-before\nhappens-before关系表示的不同线程之间的操作先后顺序。如果A happens-before B，则A的内存状态将在B操作执行之前就可见。happends-before关系满足传递性、非自反性和非对称性。happens before包含了inter-thread happens before和synchronizes-with两种关系。\nsynchronizes-with\nsynchronizes-with关系强调的是变量被修改之后的传播关系（propagate）， 即如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的[9]。另外synchronizes-with可以被认为是跨线程间的happends-before关系。显然，满足synchronizes-with关系的操作一定满足happens-before关系了。\nCarries dependency\n同一个线程内，表达式A sequenced-before 表达式B，并且表达式B的值是受表达式A的影响的一种关系， 称之为\"Carries dependency\"。这个很好理解，例如：\nint *a = \u0026var1;\nint *b = \u0026var2;\nc = *a + *b;\n\n了解了上面一些基本概念，下面我们来一起学习一下内存模型吧。\n2. C11/C++11内存模型\nC/C++11标准中提供了6种memory order，来描述内存模型[6]:\nenum memory_order {\n    memory_order_relaxed,\n    memory_order_consume,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_acq_rel,\n    memory_order_seq_cst\n};\n每种memory order的规则可以简要描述为：\n枚举值\t定义规则\nmemory_order_relaxed\t不对执行顺序做任何保证\nmemory_order_consume\t本线程中，所有后续的有关本原子类型的操作，必须在本条原子操作完成之后执行\nmemory_order_acquire\t本线程中，所有后续的读操作必须在本条原子操作完成后执行\nmemory_order_release\t本线程中，所有之前的写操作完成后才能执行本条原子操作\nmemory_order_acq_rel\t同时包含memory_order_acquire和memory_order_release标记\nmemory_order_seq_cst\t全部存取都按顺序执行\n\t\n\n?\n 下面我们来举例一一说明，扒开内存模型的神秘面纱。\n2.1 memory order releaxed\nrelaxed表示一种最为宽松的内存操作约定，Relaxed ordering 仅仅保证load()和store()是原子操作， 除此之外，不提供任何跨线程的同步[5]。\n                   std::atomic\u003cint\u003e x = 0;     // global variable\n                   std::atomic\u003cint\u003e y = 0;     // global variable\n\t\t  \nThread-1:                                  Thread-2:\nr1 = y.load(memory_order_relaxed); // A    r2 = x.load(memory_order_relaxed); // C\nx.store(r1, memory_order_relaxed); // B    y.store(42, memory_order_relaxed); // D\n\n上面的多线程模型执行的时候，可能出现r2 == r1 == 42。要理解这一点并不难，因为CPU在执行的时候允许局部指令重排reorder，D可能在C前执行。如果程序的执行顺序是 D -\u003e A -\u003e B -\u003e C，那么就会出现r1 == r2 == 42。\n如果某个操作只要求是原子操作，除此之外，不需要其它同步的保障，那么就可以使用 relaxed ordering。程序计数器是一种典型的应用场景：\n#include \u003ccassert\u003e\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n#include \u003cthread\u003e\n#include \u003catomic\u003e\n\nstd::atomic\u003cint\u003e cnt = {0};\nvoid f()\n{\n    for (int n = 0; n \u003c 1000; ++n) {\n        cnt.fetch_add(1, std::memory_order_relaxed);\n    }\n}\nint main()\n{\n    std::vector\u003cstd::thread\u003e v;\n    for (int n = 0; n \u003c 10; ++n) {\n        v.emplace_back(f);\n    }\n    for (auto\u0026 t : v) {\n        t.join();\n    }\n    assert(cnt == 10000);    // never failed\n    return 0;\n}\ncnt是共享的全局变量，多个线程并发地对cnt执行RMW（Read Modify Write）原子操作。这里只保证cnt的原子性，其他有依赖cnt的地方不保证任何的同步。\n2.2 memory order consume\nconsume要搭配release一起使用。很多时候，线程间只想针对有依赖关系的操作进行同步， 除此之外线程中其他操作顺序如何不关心，这时候就适合用consume来完成这个操作。例如：\nb = *a;\nc = *b\n第二行的变量c依赖于第一行的执行结果，因此这两行代码是\"Carries dependency\"关系。显然，由于consume是针对有明确依赖关系的语句来限定其执行顺序的一种内存顺序， 而releaxed不提供任何顺序保证， 所以consume order要比releaxed order要更加地Strong。\n#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n#include \u003cstring\u003e\n\nstd::atomic\u003cstd::string*\u003e ptr;\nint data;\n\nvoid producer()\n{\n    std::string* p  = new std::string(\"Hello\");\n    data = 42;\n    ptr.store(p, std::memory_order_release);\n}\n\nvoid consumer()\n{\n    std::string* p2;\n    while (!(p2 = ptr.load(std::memory_order_consume)))\n        ;\n    assert(*p2 == \"Hello\");  // never fires: *p2 carries dependency from ptr\n    assert(data == 42);      // may or may not fire: data does not carry dependency from ptr\n}\n\nint main()\n{\n    std::thread t1(producer);\n    std::thread t2(consumer);\n    t1.join();\n    t2.join();\n}\nassert(*p2 == \"Hello\")永远不会失败，但assert(data == 42)可能会。原因是：\np2和ptr直接有依赖关系，但data和ptr没有直接依赖关系，\n尽管线程1中data赋值在ptr.store()之前，线程2看到的data的值还是不确定的。\n2.3 memory order acquire\nacquire和release也必须放到一起使用。 release和acquire构成了synchronize-with关系，也就是同步关系。在这个关系下：线程A中所有发生在release x之前的值的写操作， 对线程B的acquire x之后的任何操作都可见。\n#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n#include \u003cstring\u003e\n#include \u003ciostream\u003e\n\nstd::atomic\u003cbool\u003e ready{ false };\nint data = 0;\nstd::atomic\u003cint\u003e var = {0};\n\nvoid sender()\n{\n    data = 42;                                              // A\n    var.store(100, std::memory_order_relaxed);              // B\n    ready.store(true, std::memory_order_release);           // C\n}\nvoid receiver()\n{\n    while (!ready.load(std::memory_order_acquire))          // D\n        ;\n    assert(data == 42);  // never failed                    // E\n    assert(var == 100);  // never failed                    // F\n}\n\nint main()\n{\n    std::thread t1(sender);\n    std::thread t2(receiver);\n    t1.join();\n    t2.join();\n}\n上面的例子中：\nsender线程中data = 42是sequence before原子变量ready的\nsender和receiver在C和D处发生了同步\n线程sender中C之前的所有读写对线程receiver都是可见的 显然， release和acquire组合在一起比release和consume组合更加Strong！\n2.4 memory order release\nrelease order一般不单独使用，它和acquire和consume组成2种独立的内存顺序搭配。\n这里就不用展开啰里啰嗦了。\n2.5 memory order acq_rel\nacq_rel是acquire和release的叠加。中文不知道该咋描述好：\nA read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.\n\n大致意思是：memory_order_acq_rel适用于read-modify-write operation， 对于采用此内存序的read-modify-write operation，我们可以称为acq_rel operation， 既属于acquire operation 也是release operation. 设有一个原子变量M上的acq_rel operation：自然的，该acq_rel operation之前的内存读写都不能重排到该acq_rel operation之后， 该acq_rel operation之后的内存读写都不能重排到该acq_rel operation之前. 其他线程中所有对M的release operation及其之前的写入都对当前线程从该acq_rel operation开始的操作可见， 并且截止到该acq_rel operation的所有内存写入都对另外线程对M的acquire operation以及之后的内存操作可见[13]。\n这里是一个例子，关于为什么要有acq_rel可以参考一下：\n#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n#include \u003cvector\u003e\n \nstd::vector\u003cint\u003e data;\nstd::atomic\u003cint\u003e flag = {0};\n \nvoid thread_1()\n{\n    data.push_back(42);\n    flag.store(1, std::memory_order_release);\n}\n \nvoid thread_2()\n{\n    int expected=1;\n    while (!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel)) {\n        expected = 1;\n    }\n}\n \nvoid thread_3()\n{\n    while (flag.load(std::memory_order_acquire) \u003c 2)\n        ;\n    assert(data.at(0) == 42); // will never fire\n}\n \nint main()\n{\n    std::thread a(thread_1);\n    std::thread b(thread_2);\n    std::thread c(thread_3);\n    a.join(); b.join(); c.join();\n}\n2.6 memory order seq_cst\nseq_cst表示顺序一致性内存模型，在这个模型约束下不仅同一个线程内的执行结果是和程序顺序一致的， 每个线程间互相看到的执行结果和程序顺序也保持顺序一致。显然，seq_cst的约束是最强的，这意味着要牺牲性能为代价。\n        atomic int x (0);               atomic int y (0);\n    x. store (1, seq cst );     ||      y. store (1, seq cst );\n    int r1 = y.load( seq cst ); ||      int r2 = x.load( seq cst );\n                assert (r1 == 1 || r2 == 1);\n\n下面是一个seq_cst的实例：\n#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ccassert\u003e\n \nstd::atomic\u003cbool\u003e x = {false};\nstd::atomic\u003cbool\u003e y = {false};\nstd::atomic\u003cint\u003e z = {0};\n \nvoid write_x()\n{\n    x.store(true, std::memory_order_seq_cst);\n}\n \nvoid write_y()\n{\n    y.store(true, std::memory_order_seq_cst);\n}\n \nvoid read_x_then_y()\n{\n    while (!x.load(std::memory_order_seq_cst))\n        ;\n    if (y.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\n \nvoid read_y_then_x()\n{\n    while (!y.load(std::memory_order_seq_cst))\n        ;\n    if (x.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\n \nint main()\n{\n    std::thread a(write_x);\n    std::thread b(write_y);\n    std::thread c(read_x_then_y);\n    std::thread d(read_y_then_x);\n    a.join(); b.join(); c.join(); d.join();\n    assert(z.load() != 0);  // will never happen\n}\n2.7 Relationship with volatile\n人的一生总是充满了疑惑。\n可能你会思考？volatile关键字能够防止指令被编译器优化，那它能提供线程间(inter-thread)同步语义吗？答案是：不能！！！\n尽管volatile能够防止单个线程内对volatile变量进行reorder，但多个线程同时访问同一个volatile变量，线程间是完全不提供同步保证。\n而且，volatile不提供原子性！\n并发的读写volatile变量是会产生数据竞争的，同时non volatile操作可以在volatile操作附近自由地reorder。\n看一个例子，执行下面的并发程序，不出意外的话，你不会得到一个为0的结果。\n#include \u003cthread\u003e\n#include \u003ciostream\u003e\n\nvolatile int count = 0;\n\nvoid increase() {\n    for (int i = 0; i \u003c 1000000; i++) {\n        count++;\n    }\n}\n\nvoid decrease() {\n    for (int i = 0; i \u003c 1000000; i++) {\n        count--;\n    }\n}\n\nint main() {\n    std::thread t1(increase);\n    std::thread t2(decrease);\n    t1.join();\n    t2.join();\n    std::cout \u003c\u003c count \u003c\u003c std::endl;\n}\n3. Reference\nThe C/C++ Memory Model: Overview and Formalization\n知乎专栏：如何理解C++的6种memory order\n理解 C++ 的 Memory Order\n理解弱内存顺序模型\n当我们在谈论 memory order 的时候，我们在谈论什么\nhttps://en.cppreference.com/w/cpp/atomic/memory_order\nYoutube: Atomic’s memory orders, what for? - Frank Birbacher [ACCU 2017]\nC++11中的内存模型下篇 - C++11支持的几种内存模型\nmemory ordering, Gavin's blog\nc++11 内存模型解读\nmemory barriers in c, MariaDB FOUNDATION, pdf\nC++ memory order循序渐进\nMemory Models for C/C++ Programers\nMemory Consistency Models: A Tutorial","showReadNum":2369,"sourceDetail":null,"sourceType":99,"status":2,"summary":"现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这是多处理器架构下并发编程里必须掌握的一个基础概念。","tagIds":[10663,10166],"title":"深入理解C11/C++11内存模型","uid":5465588,"updateTime":1591255179,"userSummary":"","userUpdateTime":0},"authorInfo":{"articleNum":0,"avatarUrl":"https://ask.qcloudimg.com/random-avatar/5465588/kn484luc7w.png","company":"","introduce":"","isProfessionVerified":0,"nickname":"Linux阅码场","privilege":1,"title":"","uid":5465588},"authorType":{"isBlogMoveAuthor":1,"isCoCreator":0,"isInternalAuthor":0,"isOriginalAuthor":0},"classify":[{"id":5,"name":"编程语言"}],"columnInfo":{"columnAvatar":"https://imgcache.qq.com/qcloud/developer/images/release/column-icons/9.png","columnDesc":"","columnId":77185,"columnName":"LINUX阅码场","createTime":1558494887,"createUid":5465588,"memberNum":1,"showArticleNum":366,"showConcernNum":217},"columnList":[{"columnAvatar":"https://imgcache.qq.com/qcloud/developer/images/release/column-icons/9.png","columnDesc":"","columnId":77185,"columnName":"LINUX阅码场","createTime":1558494887,"createUid":5465588,"memberNum":1,"showArticleNum":366,"showConcernNum":217}],"editTime":0,"isTencent":false,"longtailTags":[],"publishTime":1591255179,"sourceDetail":{"blogType":1,"blogUrl":"","channelSource":"wechat","originalTime":"2020-06-01","sourceAuthor":"Linux阅码场","sourceLink":"https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==\u0026mid=2652667380\u0026idx=1\u0026sn=08512d3b36259d211affad4fd4aea9f5\u0026chksm=810f3b69b678b27f14e3a18102f6e73ee559982b450f6d0dbe50ce3ffb85507dcdc0288e0129#rd","wechatNickName":"Linux阅码场","wechatUserName":"LinuxDev"},"tags":[{"categoryId":99,"createTime":"2018-09-06T18:30:02+08:00","groupId":0,"groupName":"","tagId":10663,"tagName":"编程算法"},{"categoryId":3,"createTime":"2018-05-11T12:03:39+08:00","groupId":10120,"groupName":"编程语言","tagId":10166,"tagName":"c++"}],"textLink":[{"ext":{"categoryId":1028,"categoryName":"通用技术 - 软件工程","desc":"编译器是一种计算机程序，用于将一种源语言（通常是高级语言）编写的程序转换成目标语言（通常是机器语言）的程序。编译器将源代码作为输入，并将其转换成目标代码，可以在计算机上直接执行。","kpCount":10,"name":"编译器","pCategoryId":1002,"termId":1908},"id":3606,"link":"https://cloud.tencent.com/developer/techpedia/1908","sources":[2],"text":"编译器"},{"ext":{"categoryId":1022,"categoryName":"通用技术 - 数据库","desc":"MariaDB是一种开源的关系型数据库管理系统（RDBMS），它是MySQL的一个分支，由MySQL的创建者Michael Widenius于2009年创建。MariaDB使用GPL（GNU通用公共许可证）作为其开源许可证，是一个社区驱动的项目，拥有活跃的开发者和用户社区。MariaDB具有与MySQL相同的特性和接口，但也包括一些新的功能和性能优化。MariaDB与MySQL兼容，可以使用MySQL的命令和工具进行管理和维护。","kpCount":7,"name":"MariaDB","pCategoryId":1002,"termId":1688},"id":23,"link":"https://cloud.tencent.com/product/tdsql","sources":[1,2],"text":"MariaDB"},{"ext":{"categoryId":1018,"categoryName":"通用技术 - 编程语言","desc":"Java是一种计算机编程语言和平台，最初由Sun Microsystems于1995年发布。它是一种面向对象的语言，具有自动内存管理和垃圾回收功能，同时具有跨平台性，可以在不同的操作系统上运行。Java平台包括Java虚拟机（JVM）、Java API和Java编译器等组件，其中JVM是Java平台的核心，它可以将Java程序编译成字节码，然后在不同的操作系统上运行。Java具有简单、安全、可靠、可移植、高效等特点，被广泛应用于企业级应用开发、Web开发、游戏开发、移动应用开发等领域。","kpCount":8,"name":"Java","pCategoryId":1002,"termId":1644},"id":3376,"link":"https://cloud.tencent.com/developer/techpedia/1644","sources":[2],"text":"Java"}]},"#url:\"/api/tag/products\",params:#tagIds:@10663,10166,,objectType:1,objectId:1638672,,":[{"adActivity":null,"cnName":"云数据库 MariaDB","desc":"腾讯云数据库 MariaDB（TencentDB for MariaDB） 让您轻松在云端部署、使用 MariaDB 数据库。MariaDB 是在 MySQL 版权被 Oracle 收购后，由 MySQL 创始人 Monty 创立，其版权授予了“MariaDB基金会（非营利性组织）”以保证 MariaDB 永远开源，良好的开源策略，是企业级应用的最优选择，主流开源社区系统/软件的数据库系统，均已默认配置 MariaDB。","docURL":"https://cloud.tencent.com/document/product/237","hasActivity":false,"icon":"https://main.qcloudimg.com/image/product/2025/32_32/blue.svg","introURL":"https://cloud.tencent.com/product/tdsql","name":"tdsql","productId":11029,"shortDesc":"由社区驱动的开源数据库，腾讯金融级数据库架构 TDSQL 的衍生","tagId":10856}],"#url:\"/api/common/runnable-codes\",params:#objectId:1638672,,":[]},"tdk":{"title":"深入理解C11/C++11内存模型-腾讯云开发者社区-腾讯云","keywords":"编程算法,c++","description":"现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这..."},"meta":{"subject":"其他-空类-编程算法,通用技术-编程语言-c++","subjectTime":"2020-06-04 15:19:39","articleSource":"W","magicSource":"N","authorType":"Z","productSlug":"tdsql"},"link":{"canonical":"https://cloud.tencent.com/developer/article/1638672"},"cssName":["Article","DraftMaster","Player"],"session":{"isLogined":false,"isQCloudLogined":false,"isQCommunityLogined":false,"isDifferentUin":false},"pvId":"7YMh8smKDCRebd_SZq1Dd","clientIp":"218.23.120.144"}},"page":"/article/[articleId]","query":{"articleId":"1638672"},"buildId":"o2QyCDQOABTsHcFsERLWY","assetPrefix":"https://qccommunity.qcloudimg.com/community","isFallback":false,"gssp":true,"appGip":true,"scriptLoader":[]}</script><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer><div class="cdc-portal-wrapper"></div><div class="cdc-portal-wrapper"></div><div id="tea-overlay-root"></div></body></html>